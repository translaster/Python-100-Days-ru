## Практическое применение функций

### Пример 1: Случайная CAPTCHA

Создайте функцию для генерации случайного кода CAPTCHA, состоящего из цифр и английских букв верхнего и нижнего регистра, длина может быть задана параметрами.

```python
import random
import string

ALL_CHARS = string.digits + string.ascii_letters


def generate_code(*, code_len=4):
    """
    Генерируем CAPTCHA указанной длины
    :param code_len: длина кода (по умолчанию 4 символа)
    :return: Случайная строка CAPTCHA, состоящая из букв и цифр верхнего и нижнего регистра
    """
    return ''.join(random.choices(ALL_CHARS, k=code_len))
```

> **Описание 1**: `digits` из модуля `string` представляет строку `'0123456789'`, состоящую из цифр от 0 до 9, а `ascii_letters` из модуля `string` представляет строку состоящую из прописных и строчных английских букв' `'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.
>
> **Примечание 2**: Функции `sample` и `choices` модуля `random` реализуют случайную выборку; `sample` делает это без putback, что означает, что элементы, взятые из выборки, не дублируются; `choices` делает это с putback, тоесть некоторые элементы могут быть выбраны повторно. Первый параметр этих двух функций представляет собой общий размер выборки, а параметр `k` - размер выборки. Следует отметить, что параметр `k` функции `choices` является именованным ключевым параметром, и при передаче параметра необходимо указывать его имя.

Приведенные выше функции можно проверить, сгенерировав 5 наборов случайных CAPTCHA с помощью следующего кода.

```python
for _ in range(5):
    print(generate_code()) 
```

Вывод:

```
59tZ
QKU5
izq8
IBBb
jIfX
```

или

```python
for _ in range(5):
    print(generate_code(code_len=6))
```

Вывод:

```
FxJucw
HS4H9G
0yyXfz
x7fohf
ReO22w
```

> **Примечание**: Мы разработали функцию `generate_code` с именованным параметром, так как он имеет значение по умолчанию, вы можете оставить его без назначения и использовать значение по умолчанию 4. Если вам нужно передать параметр в функцию, то должны указать имя параметра `code_len`.

### Пример 2: Определение простого числа

Разработайте функцию, которая определяет, является ли заданное целое положительное число больше 1 простым числом. Простое число - это целое положительное число (больше 1), которое делится только на 1 и на само себя. Если целое положительное число больше 1, $\small{N}$, является простым, это означает, что у него нет множителей от 2 до $\small{N-1}$.

```python
def is_prime(num: int) -> bool:
    """
    Определим, является ли целое положительное число простым или нет
    :param num: целое положительное число больше 1
    :return: True, если num является простым, False в противном случае
    """
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True
```

> **Пояснение 1**: `: int` после параметра `num` функции `is_prime` выше используется для обозначения типа параметра, что никак не влияет на результат выполнения кода, но очень хорошо улучшает читабельность кода. Аналогично, `-> bool` после списка аргументов используется для обозначения типа возвращаемого значения функции, что также не влияет на результат выполнения кода, но дает понять, что вызов функции приведет к получению булевого значения, либо `True`, либо `False`.
>
> **Примечание 2**: В приведенном выше цикле нет необходимости переходить от 2 к $\small{N-1}$, поскольку если цикл дошел до $\small{\sqrt{N}}$ и еще не нашел множитель для $\small{N}$, то после $\small{\sqrt{N}}$ также не будет множителя для $\small{\sqrt{N}}$, и вы можете подумать о том, почему так.

### Пример 3: Наибольший общий делитель и наименьшее общее кратное

Создайте функцию, которая вычисляет наибольший общий делитель и наименьшее общее кратное двух положительных целых чисел. Наибольший общий делитель $\small{x}$ и $\small{y}$ - это наибольшее целое число, на которое можно разделить и $\small{x}$, и $\small{y}$, наибольший общий делитель $\small{x}$ и $\small{y}$ равен 1, если они взаимно просты; а наименьшее общее кратное $\small{x}$ и $\small{y}$ - это наименьшее целое число, которое может быть разделено и на $\small{x}$, и на $\small{y}$. Если $\small{x}$ и $\small{y}$ взаимно просты, то их наименьшее общее кратное равно $\small{x \times y}$. Важно отметить, что вычисление наибольшего общего делителя и наименьшего общего кратного - это две разные функции, и их следует оформлять как две функции, а не помещать в одну.

```python
def lcm(x: int, y: int) -> int:
    """Найти наименьшее общее кратное"""
    return x * y // gcd(x, y)


def gcd(x: int, y: int) -> int:
    """Наибольший общий делитель"""
    while y % x != 0:
        x, y = y % x, x
    return x
```

> Функция `lcm`, которая находит наименьшее общее кратное, вызывает функцию `gcd`, которая находит наибольший общий делитель и вычисляет наименьшее общее кратное по формуле $\frac{x \times y}{ gcd(x, y)}$.

### Пример 4: Статистика данных

Предполагая, что данные выборки хранятся в списке, разработайте функции, которые вычисляют статистическую информацию о данных выборки. Статистика обычно включает: среднее арифметическое, медиану, экстремальное отклонение (разность между максимальным и минимальным значениями), дисперсию, стандартное отклонение, коэффициент вариации и т.д. Формулы приведены ниже.

Среднее арифметическое:

$$
\bar{x} = \frac{\sum_{i=1}^{n}x_{i}}{n} = \frac{x_{1}+x_{2}+\cdots +x_{n}}{n}
$$

Дисперсия выборки：

$$
s^2 = \frac {\sum_{i=1}^{n}(x_i - \bar{x})^2} {n-1}
$$

Стандартное отклонение выборки：

$$
s = \sqrt{\frac{\sum_{i=1}^{n}(x_i - \bar{x})^2}{n-1}}
$$

Коэффициент вариации：

$$
CV = \frac{s}{\bar{x}}
$$

```python
def ptp(data):
    """Экстремальное отклонение"""
    return max(data) - min(data)


def mean(data):
    """Среднее арифметическое"""
    return sum(data) / len(data)


def median(data):
    """Медиана"""
    temp, size = sorted(data), len(data)
    if size % 2 != 0:
        return temp[size // 2]
    else:
        return mean(temp[size // 2 - 1:size // 2 + 1])


def var(data, ddof=1):
    """Дисперсия"""
    x_bar = mean(data)
    temp = [(num - x_bar) ** 2 for num in data]
    return sum(temp) / (len(temp) - ddof)


def std(data, ddof=1):
    """Стандартное отклонение"""
    return var(data, ddof) ** 0.5


def cv(data, ddof=1):
    """Коэффициент вариации"""
    return std(data, ddof) / mean(data)


def describe(data):
    """Вывод статистики"""
    print(f'Среднее арифметическое: {mean(data)}')
    print(f'Медиана: {median(data)}')
    print(f'Экстремальное отклонение: {ptp(data)}')
    print(f'Дисперсия: {var(data)}')
    print(f'Стандартное отклонение: {std(data)}')
    print(f'Коэффициент вариации: {cv(data)}')
```

> **Описание 1**: Медиана - это число, которое находится в середине данных, когда данные отсортированы по возрастанию или убыванию, и описывает средний уровень данных. Медиана вычисляется в двух случаях: когда объем данных $n$ нечетный, медианой является элемент, расположенный на позиции $\frac{n + 1}{2}$; когда объем данных $\small{n}$ четный, медианой является среднее значение элементов, расположенных на позициях $\frac{n}{2}$ и $\frac{n}{2} + 1$.
>
> **Пояснение 2**: функция вычисления дисперсии и стандартного отклонения имеет параметр `ddof`, который представляет собой степень свободы, которую можно корректировать, по умолчанию значение равно 1. При вычислении выборочной дисперсии и выборочного стандартного отклонения необходимо делать поправку на степень свободы; при вычислении общей дисперсии и общего стандартного отклонения можно присвоить параметру `ddof` значение 0, т.е. поправка на степень свободы не требуется.
>
> **Примечание 3**: Функция `describe` собирает функции статистики, описанные выше, для вывода статистической информации о данных. На самом деле, в стандартной библиотеке Python есть модуль `statistics`, который уже содержит функции для получения статистической информации для заинтересованного читателя.

### Пример 5: Выбор случайного числа из двухцветного шара

Мы используем функции, чтобы восстановить пример выбора случайных чисел из двухцветного шара, изученный ранее ("День 09: Часто используемые структуры данных - список-2"), инкапсулировать функции генерации случайных чисел и вывода набора чисел в две функции соответственно, а затем вызвать эти функции для реализации функции машинного выбора `N` чисел.

```python
"""
Процедура выбора случайного числа из двух цветных шаров

Author: Ло Хао
Version: 1.3
"""
import random

RED_BALLS = [i for i in range(1, 34)]
BLUE_BALLS = [i for i in range(1, 17)]


def choose():
    """
    Сгенерировать набор случайных чисел
    :return: Сохраненный список случайных чисел
    """
    selected_balls = random.sample(RED_BALLS, 6)
    selected_balls.sort()
    selected_balls.append(random.choice(BLUE_BALLS))
    return selected_balls


def display(balls):
    """
    Вывод набора чисел в формате
    :param balls: содержит список случайных чисел
    """
    for ball in balls[:-1]:
        print(f'\033[031m{ball:0>2d}\033[0m', end=' ')
    print(f'\033[034m{balls[-1]:0>2d}\033[0m')


n = int(input('Сколько создать чисел: '))
for _ in range(n):
    display(choose())
```

> **Пояснение**: Посмотрите на строку кода `display(choose())`, здесь мы сначала получаем набор случайных чисел с помощью функции `choose`, затем берем возвращаемое значение функции `choose` в качестве параметра функции `display`, и выводим выбранные случайные числа на экран с помощью функции `display`. Логика рефакторингового кода очень понятна, а сам код стал гораздо более читабельным. Если кто-то обернет эти две функции для вас, а вы будете только вызывающей стороной, вам не нужно заботиться о внутренней реализации функций `choose` и `display`; все, что вам нужно знать, это то, что вызов функции `choose` генерирует набор случайных чисел, а вызов функции `display` передает список случайных чисел, которые вы можете затем вывести. В будущем, когда мы будем использовать различные сторонние библиотеки Python, нас вообще не будет волновать базовая реализация; все, что нам нужно будет знать - это какую функцию вызвать для решения задачи.

### Резюме

При написании кода, особенно при разработке коммерческих проектов, вы должны сознательно **инкапсулировать относительно независимые и многократно используемые операции в функции**, чтобы и вы, и другие члены команды могли использовать эти операции путем вызова функции, сокращая тем самым объем повторяющейся и утомительной работы.