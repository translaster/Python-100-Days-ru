## Часто используемые структуры данных списка-2

### Методы списков

Переменные типа list имеют ряд методов, которые могут помочь нам манипулировать списком. Предположим, у нас есть список с именем `foos`, и у списка есть метод `bar`, тогда синтаксис для использования метода списка будет `foos.bar()`, что является синтаксисом для вызова метода объекта по объектной ссылке. Более подробно этот синтаксис будет рассмотрен позже, когда мы будем говорить об объектно-ориентированном программировании, которое также известно как отправка сообщений объектам.

#### Добавление и удаление элементов

Список - это изменяемый массив, а это означает, что мы можем добавлять элементы в массив, удалять элементы и изменять элементы в существующем массиве. Мы можем использовать метод списка `append` для добавления элементов и метод `insert` для вставки элементов. Append означает добавление элемента в конец списка, а insert добавляет новый элемент в указанную позицию, как показано в коде ниже.

```python
languages = ['Python', 'Java', 'C++']
languages.append('JavaScript')
print(languages)  # ['Python', 'Java', 'C++', 'JavaScript']
languages.insert(1, 'SQL')
print(languages)  # ['Python', 'SQL', 'Java', 'C++', 'JavaScript']
```

Мы можем использовать метод списка `remove` списка для удаления указанного элемента из списка. Следует отметить, что если удаляемый элемент не находится в списке, то это вызовет ошибку `ValueError` и приведет к аварийному завершению программы, поэтому рекомендуется при удалении элемента использовать операции над членами, о которых мы говорили ранее. Мы также можем использовать метод `pop` для удаления элементов из списка. По умолчанию метод `pop` удаляет последний элемент в списке, но, конечно, ему можно задать позицию и удалить элемент в указанной позиции. При использовании метода `pop` для удаления элемента, если значение индекса выходит за пределы диапазона, будет выдано исключение `IndexError`, что приведет к аварийному завершению программы. Кроме того, у списка есть метод `clear`, очищающий элементы списка, код которого показан ниже.

```python
languages = ['Python', 'SQL', 'Java', 'C++', 'JavaScript']
if 'Java' in languages:
    languages.remove('Java')
if 'Swift' in languages:
    languages.remove('Swift')
print(languages)  # ['Python', 'SQL', C++', 'JavaScript']
languages.pop()
temp = languages.pop(1)
print(temp)       # SQL
languages.append(temp)
print(languages)  # ['Python', C++', 'SQL']
languages.clear()
print(languages)  # []
```

> **Примечание**: Метод `pop` удаляет элемент и получает его, в приведенном выше коде мы присвоили элемент, удаленный методом `pop`, переменной с именем `temp`. Конечно, при желании вы можете добавить этот элемент в список снова, как это делает приведенный выше код `languages.append(temp)`.

Вот еще одна небольшая проблема, например, если в списке `languages` есть несколько `'Python``, используем ли мы `languages.remove('Python')` для удаления всех `'Python`` или первого `'Python``, так что вы можете догадаться и попробовать сами.

На самом деле есть еще один способ удаления элементов из списка - использовать ключевое слово Python `del`, за которым следует элемент, который вы хотите удалить. Нет никакой существенной разницы между этим подходом и использованием метода `pop` для указания индекса для удаления элемента, но последний возвращает удаленный элемент, и первый немного лучше с точки зрения производительности, потому что `del` соответствует основной директиве байткода `DELETE_ SUBSCR`, а `pop` соответствует лежащим в основе байткода директивам `CALL_METHOD` и `POP_TOP`, так что если вы этого не понимаете, оставьте это.

```python
items = ['Python', 'Java', 'C++']
del items[1]
print(items)  # ['Python', 'C++']
```

#### Позиция и частота элементов

Метод списка `index` находит индексную позицию элемента в списке; если указанный элемент не найден, метод `index` вызывает ошибку `ValueError`; а метод `count` списка подсчитывает, сколько раз элемент встречается в списке, как показано в следующем коде.

```python
items = ['Python', 'Java', 'Java', 'C++', 'Kotlin', 'Python']
print(items.index('Python'))     # 0
# Поиск 'Python' с позиции индекса 1 
print(items.index('Python', 1))  # 5
print(items.count('Python'))     # 2
print(items.count('Kotlin'))     # 1
print(items.count('Swfit'))      # 0
# Поиск 'Java' с позиции индекса 3
print(items.index('Java', 3))    # ValueError: 'Java' is not in list
```

#### Сортировка и реверсирование элементов

Операция над списком `sort` сортирует элементы списка, а операция `reverse` меняет их местами, как показано в приведенном ниже коде.

```python
items = ['Python', 'Java', 'C++', 'Kotlin', 'Swift']
items.sort()
print(items)  # ['C++', 'Java', 'Kotlin', 'Python', 'Swift']
items.reverse()
print(items)  # ['Swift', 'Python', 'Kotlin', 'Java', 'C++']
```

### Генераторы списков

В Python списки также можно создавать с помощью специального синтаксиса, называемого генеративным. Ниже мы рассмотрим на примере преимущества использования генераторов списков для их создания.

Сценарий 1: Создайте список чисел от `1` до `99`, которые делятся на `3` или `5`.

```python
items = []
for i in range(1, 100):
    if i % 3 == 0 or i % 5 == 0:
        items.append(i)
print(items)
```

Ниже приведен код, позволяющий сделать то же самое с помощью генератора списков.

```python
items = [i for i in range(1, 100) if i % 3 == 0 or i % 5 == 0]
print(items)
```

Сценарий 2: Имеется список целых чисел `nums1`, создайте новый список `nums2`, где элементы в `nums2` являются квадратами соответствующих элементов в `nums1`.

```python
nums1 = [35, 12, 97, 64, 55]
nums2 = []
for num in nums1:
    nums2.append(num ** 2)
print(nums2)
```

Ниже приведен код, позволяющий сделать то же самое с помощью генератора списков.

```python
nums1 = [35, 12, 97, 64, 55]
nums2 = [num ** 2 for num in nums1]
print(nums2)
```

Сценарий 3: Имеется список целых чисел `nums1`, создайте новый список `nums2` и поместите элементы из `nums1`, которые больше `50`, в `nums2`.

```python
nums1 = [35, 12, 97, 64, 55]
nums2 = []
for num in nums1:
    if num > 50:
        nums2.append(num)
print(nums2)
```

Ниже приведен код, позволяющий сделать то же самое с помощью генератора списков.

```python
nums1 = [35, 12, 97, 64, 55]
nums2 = [num for num in nums1 if num > 50]
print(nums2)
```

Создание списков с помощью генераторов списков не только просто и элегантно, но и превосходит цикл `for-in` и метод `append` для добавления элементов в пустой список. Причина, по которой генеративный метод лучше, заключается в том, что интерпретатор Python имеет директивы байткода, специфичные для генеративного метода (директива `LIST_APPEND`), тогда как циклы `for` добавляют элементы в списки с помощью вызова методов (директивы `LOAD_METHOD` и `CALL_METHOD`), что само по себе является относительно трудоемкой операцией. Неважно, если вы этого не понимаете, просто запомните вывод о том, что "**генеративный синтаксис настоятельно рекомендуется для создания списков**".

### Вложенные списки

Язык Python не ограничивает элементы списка одним типом данных, что означает, что элементы списка могут быть любого типа данных, включая, конечно, сам список. Если элементы списка также являются списками, то мы можем называть их вложенными списками. Вложенные списки можно использовать для представления таблиц или математических матриц, например, если мы хотим хранить оценки 5 студентов по 3 предметам, то можем использовать список, как показано ниже.

```python
scores = [[95, 83, 92], [80, 75, 82], [92, 97, 90], [80, 78, 69], [65, 66, 89]]
print(scores[0])
print(scores[0][1])
```

Для вложенного списка выше каждый элемент эквивалентен оценке студента за 3 курса, например, `[95, 83, 92]`, а `83` в этом списке представляет оценку студента за определенный курс, и если вы хотите получить доступ к этому значению, то можете использовать операцию индексирования дважды `scores[0][1]`, где `scores[0]` получает список `[95, 83 , 92]`, а с помощью операции индексирования `[1]` получаем второй элемент в этом списке.

Если вы хотите ввести оценки 5 студентов по 3 предметам с помощью клавиатуры и сохранить их в списке, то можете использовать код, показанный ниже.

```python
scores = []
for _ in range(5):
    temp = []
    for _ in range(3):
        score = int(input('Пожалуйста, введите: '))
        temp.append(score)
    scores.append(temp)
print(scores)
```

Если мы хотим сгенерировать оценки 5 студентов по 3 предметам и сохранить их в списке с помощью генерации случайных чисел, то можем использовать формулу генератора списка, как показано в приведенном ниже коде.

```python
import random

scores = [[random.randrange(60, 101) for _ in range(3)] for _ in range(5)]
print(scores)
```

> **Примечание**: Приведенный выше код `[random.randrange(60, 101) for _ in range(3)] ` может сгенерировать список, состоящий из 3 случайных целых чисел, мы снова поместим этот код в другой генератор списков в качестве элементов списка, так что всего будет сгенерировано 5 элементов, и в итоге получим вложенный список.

### Применение списков

Ниже приведен пример двухцветного шара, выбранного случайным образом, чтобы объяснить применение списков. Двухцветный шар - это лотерейный билет, выпущенный Китайским центром распространения и управления благотворительными лотереями. Каждая ставка состоит из `6` красных шаров и `1` синего шара. Номера красных шаров выбираются от `1` до `33`, а номера синих шаров - от `1` до `16`. Для каждой ставки необходимо выбрать `6` номеров красных шаров и `1` номер синего шара, как показано ниже.

<img src="res/day09/lottery.png" style="zoom:85%;">

> **Подсказка**: На Zhihu есть довольно замечательная дискуссия о природе различных форм внутренних лотерей, которой я поделюсь здесь: "**Представьте себе человека, который получает что-то за ничего, чтобы обмануть группу людей, которые хотят получить что-то за ничего, и в конечном итоге накормить группу людей, которые действительно получают что-то за ничего**". Многие люди, не имеющие представления о вероятности, считают, что вероятность выигрыша или невыигрыша лотерейного билета равна 50 %; а многие другие думают, что если вероятность выигрыша лотерейного билета равна 1 %, то, купив лотерейный билет 100 раз, вы обязательно выиграете, и все это очень абсурдные идеи. Поэтому, **цените жизнь, держитесь подальше от азартных игр, особенно если вы ничего не знаете о вероятности**!

Ниже мы сгенерируем набор случайных чисел с помощью программы на Python.

```python
"""
Процедура выбора случайного числа из двух цветных шариков

Author: Ло Хао
Version: 1.0
"""
import random

red_balls = list(range(1, 34))
selected_balls = []
# Добавление 6 красных шариков в контрольный список
for _ in range(6):
    # Генерация случайного целого числа, 
    # представляющего индексную позицию выбранного красного шара
    index = random.randrange(len(red_balls))
    # Удаление выбранного шара из списка красных шаров и добавление его в список выбранных
    selected_balls.append(red_balls.pop(index))
# Сортировка выбранных красных шариков
selected_balls.sort()
# Вывод выбранного красного шара
for ball in selected_balls:
    print(f'\033[031m{ball:0>2d}\033[0m', end=' ')
# Случайным образом выбираем 1 синий шар
blue_ball = random.randrange(1, 17)
# Вывести выбранный синий шар
print(f'\033[034m{blue_ball:0>2d}\033[0m')
```

> **Примечание**: Приведенный выше код `print(f'\033[0m... \033[0m')` - это управление цветом выводимого содержимого, красный шарик выводится как красный, а синий - как синий. Многоточие обозначает содержимое, которое мы хотим вывести, `\033[0m` - это управляющий код, он означает отключение всех атрибутов, то есть предыдущий управляющий код будет недействительным, также его можно понимать как разделитель, `0` перед `m` означает, что отображение консоли будет по умолчанию, `0` можно опустить, `1` означает подсветку, `5` означает мигание, `7` означает инвертированное отображение и т.д. Между `0` и `m` можно писать числа, обозначающие цвета, например `30` для черного, `31` для красного, `32` для зеленого, `33` для желтого, `34` для синего и т.д.

Мы также можем использовать функции `sample` и `choice`, предоставляемые модулем `random`, чтобы упростить приведенный выше код, первая может быть достигнута путем случайной выборки без воспроизведения, а вторая - путем случайного выбора элемента, модифицированный код показан ниже.

```python
"""
Процедура выбора случайного числа из двух цветных шариков

Author: Ло Хао
Version: 1.1
"""
import random

red_balls = [i for i in range(1, 34)]
blue_balls = [i for i in range(1, 17)]
# 6 красных шаров, взятых наугад из списка красных шаров (выборка без возврата)
selected_balls = random.sample(red_balls, 6)
# Сортировка выбранных красных шариков
selected_balls.sort()
# Вывести выбранный красный шар
for ball in selected_balls:
    print(f'\033[031m{ball:0>2d}\033[0m', end=' ')
# Случайным образом вытягивается 1 синий шар из списка синих шаров
blue_ball = random.choice(blue_balls)
# Вывести выбранный синий шар
print(f'\033[034m{blue_ball:0>2d}\033[0m')
```

Чтобы добиться случайной генерации `N` чисел ставок, нам нужно просто поместить приведенный выше код в цикл, повторяющийся `N` раз, как показано ниже.

```python
"""
Процедура выбора случайного числа из двух цветных шаров

Author: Ло Хао
Version: 1.2
"""
import random

n = int(input('Создайте несколько номеров: '))
red_balls = [i for i in range(1, 34)]
blue_balls = [i for i in range(1, 17)]
for _ in range(n):
    # 6 красных шаров, взятых наугад из списка красных шаров (выборка без возврата)
    selected_balls = random.sample(red_balls, 6)
    # Сортировка выбранных красных шариков
    selected_balls.sort()
    # Вывести выбранный красный шар
    for ball in selected_balls:
        print(f'\033[031m{ball:0>2d}\033[0m', end=' ')
    # Случайным образом вытягивается 1 синий шар из списка синих шаров
    blue_ball = random.choice(blue_balls)
    # Вывести выбранный синий шар
    print(f'\033[034m{blue_ball:0>2d}\033[0m')
```

Мы запускаем приведенный выше код в PyCharm, набрав `5`, и он запускается, как показано ниже.

<img src="res/day09/lottery_run_result.png" style="zoom:35%;">

Мимоходом я хотел бы познакомить вас с сторонней библиотекой Python под названием rich, которая помогает нам создавать самые красивые выходные данные самым простым способом. Вы можете установить эту стороннюю библиотеку с помощью инструмента управления пакетами Python pip в терминале, или для тех, кто использует PyCharm, вы, конечно, должны использовать команду pip в окне терминала PyCharm, чтобы установить rich через команду в окне терминала PyCharm, как показано ниже.

```bash
pip install rich
```

<img src="res/day09/run_pip_in_terminal.png" style="zoom:50%;">

Как показано на рисунке выше, после успешной установки rich мы можем управлять выводом с помощью кода, показанного ниже.

```python
"""
Процедура выбора случайного числа из двух цветных шариков

Author: Ло Хао
Version: 1.3
"""
import random

from rich.console import Console
from rich.table import Table

# Создание консоли
console = Console()

n = int(input('Создайте несколько номеров: '))
red_balls = [i for i in range(1, 34)]
blue_balls = [i for i in range(1, 17)]

# Создание таблицы и добавление заголовков
table = Table(show_header=True)
for col_name in ('Серийный номер', 'Красный шар', 'Синий шар'):
    table.add_column(col_name, justify='center')

for i in range(n):
    selected_balls = random.sample(red_balls, 6)
    selected_balls.sort()
    blue_ball = random.choice(blue_balls)
    # Добавление строк в таблицу (серийный номер, красный шар, синий шар)
    table.add_row(
        str(i + 1),
        f'[red]{" ".join([f"{ball:0>2d}" for ball in selected_balls])}[/red]',
        f'[blue]{blue_ball:0>2d}[/blue]'
    )

# Вывод формы через консоль
console.print(table)
```

> **Пояснение**: в строке 31 приведенного выше кода используется синтаксис генератора списков для преобразования номера красного шара в строку и сохранения ее в списке, `" ".join([...])` Строка объединяет несколько строк в списке пробелами, чтобы получилась полная строка, так что если вы не понимаете этого, можете пока оставить. Строка `[red]...[/red]` используется для установки красного цвета вывода, а `[blue]...[/blue]` в строке 32 используется для установки синего цвета вывода. Для получения дополнительной информации о библиотеке rich обратитесь к [официальной документации](https://github.com/textualize/rich/blob/master/README.cn.md).

Окончательный вывод показан на следующем рисунке, глядя на который, разве настроение не становится немного лучше.

<img src="res/day09/output_using_rich.png" style="zoom:50%;">

### Резюме

Список в Python - это динамически расширяемый массив, элементы которого постоянно хранятся в памяти компьютера, чтобы к ним можно было обращаться произвольно (извлекая соответствующий элемент по правильному индексу и за время, не зависящее от количества элементов в списке). Нам не нужно касаться этих базовых деталей хранения, и не нужно понимать в списке каждого метода асимптотическую временную сложность (связь между временем, затрачиваемым на выполнение метода, и количеством элементов списка), мы учимся использовать список для решения задач работы, я думаю, это важнее.