## Функции и модули

Прежде чем мы рассмотрим содержание этого урока, давайте разберем вопрос по математике, в котором спрашивается, сколько существует наборов целых положительных решений для следующего уравнения.

$$
x_{1} + x_{2} + x_{3} + x_{4} = 8
$$

Как вы уже догадались, эта задача эквивалентна тому, сколько существует решений разделить 8 яблок на четыре группы по меньшей мере по одному яблоку в каждой, и сколько существует решений поставить три перегородки между 7 промежутками, разделяющими 8 яблок, и разделить яблоки на четыре группы, поэтому ответ равен $\small{C_{7}^{3} = 35}$, где $\small{C_{7}^{3}}$ представляет собой количество комбинаций из 7 вариантов по 3. Формула показана ниже.

$$
C_m^n = \frac {m!} {n!(m-n)!}
$$

Основываясь на том, что мы узнали ранее, можем вычислить $\small{m!}$, $\small{n!}$ и $\small{(m-n)!}$ путем выполнения кумулятивного умножения в цикле соответственно, а затем получить комбинированное число $\small{C_{m}^{n}}$ путем деления следующим образом.

```python
"""
Введите m и n и вычислите значение комбинаторного числа C(m,n)

Version: 1.0
Author: Ло Хао
"""

m = int(input('m = '))
n = int(input('n = '))
# Вычисление факториала m
fm = 1
for num in range(1, m + 1):
    fm *= num
# Вычисление факториала числа n
fn = 1
for num in range(1, n + 1):
    fn *= num
# Вычисление факториала m-n
fk = 1
for num in range(1, m - n + 1):
    fk *= num
# Вычисление значения C(M,N)
print(fm // fn // fk)
```

Ввод:

```
m = 7
n = 3
```

Вывод:

```
35
```

Хотя значения $\small{m}$, $\small{n}$ и $\small{m - n}$ разные, существенной разницы между этими тремя частями кода нет, и они являются повторяющимся кодом. Гуру программирования мирового уровня *Мартин Фаулер* однажды сказал: "**Код имеет много плохих качеств, и повторение - один из худших!**". Чтобы писать качественный код, сначала нужно решить проблему дублирующегося кода. Для приведенного выше кода мы можем инкапсулировать функцию факториала в блок кода под названием "function", где нам нужно вычислить факториал, мы просто "вызываем функцию", чтобы добиться повторного использования функции факториала.

### Определение функций


Математические функции обычно имеют вид $\small{y = f(x)}$ или $\small{z = g(x, y)}$, где $\small{y = f(x)}$, $\small{f}$ - имя функции, $\small{x}$ - независимая переменная функции, $\small{y}$ - зависимая переменная функции, а $\small{g}$ - имя функции, $\small{g}$ и $\small{y}$ - независимая переменная функции. \small{z = g(x, y)}$, $\small{g}$ - имя функции, $\small{x}$ и $\small{y}$ - независимые переменные функции, а $\small{z}$ - зависимая переменная функции. Функции в Python соответствуют этой структуре, каждая функция имеет свое имя, независимую переменную и зависимую переменную. Независимые переменные функции Python обычно называют аргументами функции, а зависимую переменную - возвращаемым значением функции.

Функции могут быть определены в Python с помощью ключевого слова `def`, и, как и переменные, каждая функция должна иметь красивое имя, с тем же соглашением об именовании, что и для переменных (вспомните соглашение об именовании переменных, о котором мы говорили ранее). В круглых скобках после имени функции можно задать параметры функции, то есть независимые переменные функции, а после завершения выполнения функции мы вернем результат функции через ключевое слово `return`, которое является зависимой переменной функции, о которой мы только что говорили. Если в функции нет оператора `return`, то функция вернет `None`, который представляет собой нулевое значение. Также функции не могут иметь независимых переменных (параметров), но круглые скобки после имени функции обязательны. То, что должна сделать функция (код для выполнения), располагается после строки определения функции с помощью отступа кода, аналогично предыдущим блокам кода в ветвящейся и циклической структуре, как показано на следующем рисунке.

<img src="res/day14/function_definition.png" style="zoom:45%;">

Далее мы поместим операцию факториала в предыдущем коде в функцию, чтобы таким образом рефакторить приведенный выше код. **Так называемый рефакторинг - это корректировка структуры кода, не влияющая на результаты его выполнения**. Код после рефакторинга показан ниже.

```python
"""
Введите m и n и вычислите значение комбинаторного числа C(m,n)

Version: 1.1
Author: Ло Хао
"""


# Определите функцию для нахождения факториала по ключевому слову def
# Независимая переменная (аргумент) num - целое неотрицательное число
# Зависимая переменная (возвращаемое значение) - факториал числа num

def fac(num):
    result = 1
    for n in range(2, num + 1):
        result *= n
    return result


m = int(input('m = '))
n = int(input('n = '))
# Вместо того чтобы писать повторяющийся код для вычисления факториала, функция вызывается напрямую
# Синтаксис вызова функции состоит в том, чтобы заключить имя функции в круглые скобки и передать аргументы
print(fac(m) // fac(n) // fac(m - n))
```

Приведенный выше код проще и элегантнее предыдущей версии. Что еще более важно, функция факториала `fac`, которую мы определили, также может быть использована повторно в другом коде, требующем факториалов. Таким образом, **использование функций помогает нам инкапсулировать код, который функционально независим и будет использоваться повторно**, так что когда он нам понадобится, вместо того, чтобы снова писать дублирующий код, мы можем **использовать существующий код**, вызвав функцию. На самом деле, в модуле `math` стандартной библиотеки Python уже есть функция `factorial`, которая реализует факториал, поэтому мы можем импортировать модуль `math` напрямую с помощью `import math`, а затем использовать `math.factorial` для вызова функции факториала; или мы можем импортировать его напрямую с помощью `from math import factorial`, мы также можем импортировать функцию `factorial` напрямую, чтобы использовать ее, как показано в следующем коде.

```python
"""
Ввести m и n и вычислить значение комбинаторного числа C(m,n)

Version: 1.2
Author: Ло Хао
"""
from math import factorial

m = int(input('m = '))
n = int(input('n = '))
print(factorial(m) // factorial(n) // factorial(m - n))
```

В будущем мы будем использовать функции, которые являются либо пользовательскими, либо содержатся в стандартной или сторонней библиотеках Python; нет смысла определять их самостоятельно, если они уже легко доступны и пригодны для использования, а "**изобретать колесо снова и снова**" - очень плохое занятие. Для приведенного выше кода, если вы считаете, что имя `factorial` слишком длинное и не очень удобное при написании кода, мы также можем задать альяс функции с помощью ключевого слова `as` при ее импорте. При вызове функции мы можем использовать псевдоним функции вместо ее прежнего имени, как показано в коде ниже.

```python
"""
Ввести m и n и вычислить значение комбинаторного числа C(m,n)

Version: 1.3
Author: Ло Хао
"""
from math import factorial as f

m = int(input('m = '))
n = int(input('n = '))
print(f(m) // f(n) // f(m - n))
```

### Параметры функций

#### Позиционные и именованные параметры

Напишем еще одну функцию, которая определяет, можно ли образовать треугольник, основываясь на длинах трех сторон, и возвращает `True`, если треугольник может быть образован, или `False` в противном случае, как показано в коде ниже.

```python
def make_judgement(a, b, c):
    """Определить, могут ли длины трех сторон образовать треугольник"""
    return a + b > c and b + c > a and a + c > b
```

Функция `make_judgement`, приведенная выше, имеет три параметра, которые называются позиционными параметрами и обычно передаются в порядке слева направо при вызове функции, а количество передаваемых параметров должно быть таким же, как и количество параметров при определении функции, как показано ниже.

```python
print(make_judgement(1, 2, 3))  # False
print(make_judgement(4, 5, 6))  # True
```

Если вы не хотите передавать значения параметров `a`, `b` и `c` в порядке слева направо, то также можете использовать именованные параметры, которые передаются в функцию в виде `parameter name=parameter value`, как показано ниже.

```python
print(make_judgement(b=2, c=3, a=1))  # False
print(make_judgement(c=6, b=4, a=5))  # True
```

При определении функции мы можем использовать `/` для задания **только позиционных аргументов** и `*` для задания **именованных аргументов** в списке аргументов. Так называемые позиционные аргументы - это аргументы, которые могут принимать значения параметров только в соответствии с позицией аргументов при вызове функции; в то время как именованные аргументы могут передаваться и приниматься только по принципу "имя параметра = значение параметра", как показано в следующем примере.

```python
# /Предыдущие параметры являются принудительными позиционными параметрами
def make_judgement(a, b, c, /):
    """Определить, могут ли длины трех сторон образовать треугольник"""
    return a + b > c and b + c > a and a + c > b


# Следующий код генерирует ошибку TypeError с сообщением "Forced positional arguments are not allowed to be given parameter names."
# TypeError: make_judgement() получила некоторые позиционные аргументы, переданные в качестве именованных
# print(make_judgement(b=2, c=3, a=1))
```

> **Примечание**: принудительный позиционный параметр - это новая возможность, появившаяся в Python 3.8, и о ней следует помнить при использовании более низких версий интерпретатора Python.

```python
# *Последний параметр является именованным
def make_judgement(*, a, b, c):
    """Определите, могут ли длины трех сторон образовать треугольник"""
    return a + b > c and b + c > a and a + c > b


# Следующий код генерирует ошибку TypeError с сообщением "Function has no positional arguments but 3 were given".
# TypeError: make_judgement() принимает 0 позиционных аргументов, но было задано 3
# print(make_judgement(1, 2, 3))
```

#### Значения аргументов по умолчанию

Python позволяет функциям иметь значения по умолчанию для своих аргументов, поэтому мы имеем возможность получения очков путем встряхивания кубика в азартной игре CRAPS (Урок 07: Ветвление и циклические структуры) в пример, о котором мы говорили ранее в этой главе, как показано в следующем коде.

```python
from random import randrange


# Определить функцию, которая перемешивает цвета.
# Независимая переменная (параметр) n функции представляет собой количество цветов, значение по умолчанию - 2.
# Зависимая переменная (возвращаемое значение) функции - это количество очков, полученных при встряхивании n цветов.
def roll_dice(n=2):
    total = 0
    for _ in range(n):
        total += randrange(1, 7)
    return total


# Если параметр не указан, то n использует значение по умолчанию 2, что означает встряхивание двух цветов
print(roll_dice())
# Передайте параметр 3, и переменной n будет присвоено значение 3, указывающее на то, что для получения количества очков встряхиваются три цвета
print(roll_dice(3))
```

Давайте рассмотрим еще более простой пример.

```python
def add(a=0, b=0, c=0):
    """Сложить три числа для нахождения суммы (математика)."""
    return a + b + c


# Вызов функции add без переданных аргументов, тогда a, b и c будут использовать значение по умолчанию 0
print(add())         # 0
# Вызываем функцию add, передавая параметр, который присваивается переменной a, переменные b и c используют значение по умолчанию 0
print(add(1))        # 1
# Вызываем функцию add, передавая два аргумента, назначенные переменным a и b, переменная c использует значение по умолчанию 0
print(add(1, 2))     # 3
# Вызываем функцию add, передавая три аргумента, присваивая значения переменным a, b и c соответственно
print(add(1, 2, 3))  # 6
```

Обратите внимание, что **аргументы со значениями по умолчанию должны располагаться после аргументов без значений по умолчанию**, иначе будет сгенерирована ошибка `SyntaxError` с сообщением об ошибке: `non-default argument follows default argument`, что переводится как "аргумент без значения по умолчанию следующет за аргументом со значением по умолчанию".

#### Неопределенное количество параметров

Python позволяет функциям поддерживать переменное количество аргументов с помощью синтаксиса выражения звездочки. Переменные параметры означают, что при вызове функции вы можете передать ей `0` или любое количество параметров. В будущем, когда вы будете работать в команде над коммерческим проектом, то, возможно, захотите разрабатывать функции для использования другими людьми, но иногда не будете знать, сколько параметров будет передано в функцию вызывающей стороной, поэтому переменное количество параметров может пригодиться.

Следующий код демонстрирует, как реализовать функцию `add`, которая суммирует произвольное количество чисел, используя переменные позиционные параметры. Параметры, передаваемые при вызове функции, хранятся в кортеже, который можно проитерировать для получения параметров, переданных в функцию.

```python
# Выражение со звездочкой используется для указания того, что args может принимать нуль или любое количество аргументов
# n аргументов, переданных при вызове функции, собираются в n-кортеж и присваиваются args
# Если аргументы не переданы, то args - это пустой кортеж.
def add(*args):
    total = 0
    # Циклический обход кортежей, содержащих переменные параметры
    for val in args:
        # Аргументы проверяются по типу
        if type(val) in (int, float):
            total += val
    return total


# Функцию add можно вызывать с нулем или с любым количеством аргументов
print(add())         # 0
print(add(1))        # 1
print(add(1, 2, 3))  # 6
print(add(1, 2, 'hello', 3.45, 6))  # 12.45
```

Если мы хотим передать несколько параметров в виде «имя параметра = значение параметра», точное количество параметров также не определено, мы также можем добавить именованные параметры в функцию, которые будут собираться в словарь, код показан ниже.

```python
# **kwargs в списке аргументов может принимать 0 или любое количество аргументов в виде именованных параметров
# Именованные аргументы, переданные при вызове функции, собираются в словарь (имена аргументов - ключи в словаре, значения аргументов - значения в словаре)
# Если ни один из аргументов-ключей не передан, то kwargs будет пустым словарем
def foo(*args, **kwargs):
    print(args)
    print(kwargs)


foo(3, 2.1, True, name='Ло Хао', age=43, gpa=4.95)
```

Вывод:

```
(3, 2.1, True)
{'name': 'Ло Хао', 'age': 43, 'gpa': 4.95}
```

### Управление функциями с помощью модулей

Независимо от того, на каком языке программирования написан код, именование переменных и функций - это головная боль, поскольку мы сталкиваемся с такими неловкими ситуациями, как **конфликты имен**. Самый простой сценарий - определить две функции с одинаковыми именами в одном файле `.py`, как показано ниже.

```python
def foo():
    print('hello, world!')


def foo():
    print('goodbye, world!')

    
foo()  # Угадайте, что выведет вызов функции foo
```

Конечно, вышеописанной ситуации можно легко избежать, но если проект является командной работой с несколькими разработчиками, в команде может быть несколько программистов, которые определили функцию с именем `foo`, как решить конфликт имен в этом случае? Ответ очень прост, каждый файл в Python представляет собой модуль, и у нас могут быть функции с одинаковыми именами в разных модулях. Когда мы используем функцию, то импортируем указанный модуль с помощью ключевого слова `import`, а затем вызываем ее с **полностью квалифицированным именем** (`имя_модуля.имя_функции`), вы можете отличить, в каком модуле в итоге используется функция `foo`, код показан ниже.

`module1.py`

```python
def foo():
    print('hello, world!')
```

`module2.py`

```python
def foo():
    print('goodbye, world!')
```

`test.py`

```python
import module1
import module2

# Вызов функции по «имя_модуля.имя_функции» (полностью квалифицированное имя).
module1.foo()  # hello, world!
module2.foo()  # goodbye, world!
```

Модули также могут быть псевдонимами с помощью ключевого слова `as` при их импорте, что позволяет нам использовать более короткие полные имена.

`test.py`

```python
import module1 as m1
import module2 as m2

m1.foo()  # hello, world!
m2.foo()  # goodbye, world!
```

В приведенных выше двух фрагментах кода мы импортируем модуль, определяющий функцию, мы также можем использовать `from... .import...` для импорта функции непосредственно из модуля, как показано в следующем коде.

`test.py`

```python
from module1 import foo

foo()  # hello, world!

from module2 import foo

foo()  # goodbye, world!
```

Однако если мы импортируем функцию с одинаковым именем из двух разных модулей, то более поздняя импортированная функция заменит предыдущую, как в следующем коде, вызов `foo` выведет `goodbye, world!`, потому что мы импортировали `foo` из `module1` сначала, а `foo` из `module2` позже. Если два `from... . import...` были написаны наоборот, это была бы совсем другая история.

`test.py`

```python
from module1 import foo
from module2 import foo

foo()  # goodbye, world!
```

Если вы хотите использовать функцию `foo` из обоих модулей в приведенном выше коде, то, как вы уже догадались, есть еще способ сделать это - псевдоним импортированной функции с помощью ключевого слова `as`, как показано в коде ниже.

`test.py`

```python
from module1 import foo as f1
from module2 import foo as f2

f1()  # hello, world!
f2()  # goodbye, world!
```

### Модули и функции в стандартной библиотеке

Стандартная библиотека Python содержит большое количество модулей и функций, упрощающих разработку. Модуль `random`, который мы уже использовали, содержит функции для генерации случайных чисел и случайной выборки; модуль `time` содержит функции для работы со временем; модуль `math`, который мы уже использовали, включает ряд математических функций для вычисления синусов, косинусов, экспоненты, логарифмов и так далее. Мы будем использовать больше модулей и функций по мере изучения Python.

В стандартной библиотеке Python есть еще один класс функций, которые вы можете использовать напрямую, без «импорта»: они называются **встроенными функциями**, и они не только полезны, но и очень часто используются; в следующей таблице перечислены некоторые из них.

| Функция (math)    | Описание                                                         |
| ------- | ------------------------------------------------------------ |
| `abs`   | Возвращает абсолютное значение числа, например, `abs(-1.3)` вернет `1.3`.           |
| `bin`   | Преобразование целого числа в двоичную строку, начинающуюся с `'0b'`, например, `bin(123)` возвращает `'0b1111011'`. |
| `chr`   | Преобразует Unicode в соответствующий символ, например, `chr(8364)` возвращает `'€'`. |
| `hex`   | Преобразует целое число в шестнадцатеричную строку, начинающуюся с `'0x'`, например, `hex(123)` возвращает `'0x7b'`. |
| `input` | Считывает строку из ввода и возвращает прочитанную строку.                          |
| `len`   | Получает длину строки, списка и т.д.                                   |
| `max`   | Возвращает максимальное значение из нескольких аргументов или итерируемого объекта, например, `max(12, 95, 37)` возвращает `95`. |
| `min`   | Возвращает наименьшее значение из нескольких аргументов или итерируемого объекта, например, `min(12, 95, 37)` возвращает `12`. |
| `oct`   | Преобразование целого числа в восьмеричную строку, начинающуюся с `'0o'`, например, `oct(123)` возвращает `'0o173'`. |
| `open`  | Открывает файл и возвращает объект файла.                                 |
| `ord`   | Преобразует символ в соответствующую кодировку Unicode, например, `ord('€')` возвращает `8364`. |
| `pow`   | Операции со степенью, например, `pow(2, 3)` возвращает `8`; `pow(2, 0.5)` возвращает `1.4142135623730951`. |
| `print` | Печать.                                                   |
| `range` | При построении последовательности диапазонов, например, `range(100)`, получается последовательность целых чисел от `0` до `99`. |
| `round` | Округление значения до указанной точности, например, `round(1.23456, 4)` возвращает `1.2346`. |
| `sum`   | Суммирование элементов в последовательности слева направо, например, `sum(range(1, 101))` возвращает `5050`. |
| `type`  | Возвращает тип объекта, например, `type(10)` вернет `int`, а `type('hello')` вернет `str`. |

###  Резюме

**Функции - это инкапсуляция кода, который относительно независим от функций и будет использоваться повторно**. Научившись определять и использовать функции, вы сможете писать более качественный код. Конечно, стандартная библиотека языка Python предоставила нам большое количество модулей и часто используемых функций, которые можно использовать, чтобы делать больше с меньшим количеством кода; если они не отвечают нашим требованиям, нам может понадобиться изменить функции, а затем управлять этими пользовательскими функциями с помощью концепции модулей.