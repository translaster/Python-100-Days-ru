## Часто используемые структуры данных - словари

Мы уже познакомили вас с тремя контейнерными типами данных в Python (списками, кортежами и множествами), но их все равно недостаточно, чтобы решить все наши проблемы. Например, если нам нужна переменная для хранения нескольких частей информации о человеке, включая имя, возраст, рост, вес, домашний адрес, номер мобильного телефона человека и номер мобильного телефона контактного лица в экстренной ситуации, вы обнаружите, что ни один из типов списков, кортежей и множеств, которые мы изучали ранее, не подходит для этого.

```python
person1 = ['Ло Хао', 55, 168, 60, '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай', '13122334455', '13800998877']
person2 = ('Ло Хао', 55, 168, 60, '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай', '13122334455', '13800998877')
person3 = {'Ло Хао', 55, 168, 60, '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай', '13122334455', '13800998877'}
```

Множества, безусловно, являются наиболее подходящими, поскольку в них не может быть дублирующихся элементов; если возраст и вес человека совпадают, то в множестве будет на один элемент меньше информации; аналогично, если номер мобильного телефона человека и номер телефона для экстренной связи совпадают, то в множестве будет на один элемент меньше информации. С другой стороны, хотя списки и кортежи могут хранить всю информацию о человеке, когда вы хотите получить его номер мобильного телефона или домашний адрес, то нужно знать, сколько элементов в списке или кортеже занимает номер мобильного телефона человека. Короче говоря, когда речь идет об описанном выше сценарии, списки, кортежи и множества - не самые подходящие варианты. Нам нужен тип данных словарь, который лучше всего подходит для сборки связанной информации и может помочь нам решить проблему моделирования реальных вещей в программах на Python.

В Китае у детей в начальной школе, у каждого, как правило, есть под рукой копия словаря Синьхуа, как показано на следующем рисунке.

<img src="res/day13/xinhua_dictionary.jpg" style="zoom:80%;">

Словарь в программе на Python очень похож на реальный словарь, поскольку в нем данные организованы в пары ключ-значение (комбинации ключей и значений), и мы можем находить значения, соответствующие ключам, и манипулировать ими. Как и в словаре Синьхуа, каждое слово (ключ) имеет соответствующее ему объяснение (значение), каждое слово и его объяснение вместе - это запись в словаре, и словарь обычно содержит много таких записей.

### Создание и использование словарей

Создать словарь в Python можно с помощью синтаксиса литералов `{}`, который аналогичен множествам, о которых мы говорили в прошлом уроке. Но элементы в словаре `{}` имеют вид пар ключ-значение, каждая из которых состоит из двух значений, разделенных `:`, причем ключ находится перед `:`, а значение - после `:`, как показано в следующем коде.

```python
xinhua = {
    'foothills': 'подножие горы',
    'road': 'дорога, место для путешествия к месту и обратно',
    'leucaena': 'название для лакрицы',
    'Lu': 'Lu Shui, название воды, т.е. реки Тоужан в современной провинции Шаньси; Lu Jiang, название воды, т.е. реки Нуцзян в провинции Юньнань'
}
print(xinhua)
person = {
    'name': 'Ло Хао',
    'age': 55,
    'height': 168,
    'weight': 60,
    'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай', 
    'tel': '13122334455',
    'emergence contact': '13800998877'
}
print(person)
```

Как видно из приведенного выше кода, использование словаря для хранения информации о человеке намного лучше, чем использование списка или кортежа, поскольку мы должны использовать ключ перед `:` для обозначения понятия записи, а за `:` следует значение, соответствующее этой записи.

Конечно, при желании мы можем создать словарь с помощью встроенной функции `dict` или генеративного синтаксиса для словарей, как показано в приведенном ниже коде.

```python
# Каждый набор аргументов в функции dict (конструкторе) представляет собой набор пар ключ-значение в словаре
person = dict(name='Ло Хао', age=55, height=168, weight=60, addr='101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай')
print(person)  # {'name': 'Ло Хао', 'age': 55, 'height': 168, 'weight': 60, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}

# Вы можете использовать встроенную в Python функцию zip для двух последовательностей и создать словарь
items1 = dict(zip('ABCDE', '12345'))
print(items1)  # {'A': '1', 'B': '2', 'C': '3', 'D': '4', 'E': '5'}
items2 = dict(zip('ABCDE', range(1, 10)))
print(items2)  # {'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5}

# Создание словарей с помощью генеративного синтаксиса
items3 = {x: x ** 3 for x in range(1, 6)}
print(items3)  # {1: 1, 2: 8, 3: 27, 4: 64, 5: 125}
```

Чтобы узнать, сколько пар ключ-значение содержится в словаре, вы по-прежнему используете функцию `len`; для итерации по словарю можете использовать цикл `for`, но обратите внимание, что `for` просто итерирует по ключам словаря, но это не страшно; после изучения операций индексирования словаря мы можем получить доступ к значениям словаря по его ключам.

```python
person = {
    'name': 'Ло Хао',
    'age': 55,
    'height': 168,
    'weight': 60,
    'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'
}
print(len(person))  # 5
for key in person:
    print(key)
```

### Операции над словарями

Для словарей, безусловно, важны операции принадлежности и индексации: первая определяет, есть ли указанный ключ в словаре, а вторая позволяет получить доступ к соответствующему значению через ключ или добавить в словарь новую пару ключ-значение. Стоит отметить, что индекс словаря отличается от индекса списка: элементы списка имеют свои порядковые номера, поэтому индекс списка - это целое число; словарь же хранит пары ключ-значение, поэтому для индексации соответствующего значения в словаре нужно использовать ключ. Важно обратить внимание на то, что **ключи в словаре должны быть неизменяемыми типами**, такими как целые числа (`int`), вещественные числа (`float`), строки (`str`), кортежи (`tuple`) и т.д., что совпадает с требованиями к типу элементов множества; очевидно, что списки (`list`), о которых мы говорили, и множества (`set`) не могут быть использованы в качестве ключа в словаре, поскольку словари также являются изменяемыми типами, но списки, множества и словари могут быть использованы в качестве значений в словаре, например:

```python
person = {
    'name': 'Ло Хао',
    'age': 55,
    'height': 168,
    'weight': 60,
    'addr': ['101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай', 'No.1, проспект Миллион Чжуан, район Сичэн, Пекин'],
    'car': {
        'brand': 'BMW X7',
        'maxSpeed': '250',
        'length': 5170,
        'width': 2000,
        'height': 1835,
        'displacement': 3.0
    }
}
print(person)
```

Вы можете взглянуть на следующий код, чтобы понять операции принадлежности и индексирования словарей.

```python
person = {'name': 'Ло Хао', 'age': 55, 'height': 168, 'weight': 60, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}

# Принадлежность
print('name' in person)  # True
print('tel' in person)   # False

# Операция индексирования
print(person['name'])
print(person['addr'])
person['age'] = 25
person['height'] = 178
person['tel'] = '13122334455'
person['signature'] = 'Ваш парень - такой гайдзин, что готов пройтись по разноцветным облакам, чтобы жениться на вашей лучшей подруге.'
print(person)

# Циклический перебор
for key in person:
    print(f'{key}:\t{person[key]}')
```

Обратите внимание, что при получении значения из словаря через индексацию, если указанного ключа нет в словаре, будет выброшено исключение `KeyError`.

### Методы словаря

Методы словаря в основном связаны с операциями над парами ключ-значение в словаре, где метод `get` может получить значение по ключу. В отличие от операций индексирования, метод `get` не выбрасывает исключение, если в словаре нет указанного ключа, а возвращает `None` или указанное значение по умолчанию, как показано в следующем коде.

```python
person = {'name': 'Ло Хао', 'age': 25, 'height': 178, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}
print(person.get('name'))       # Ло Хао
print(person.get('sex'))        # None
print(person.get('sex', True))  # True
```

Если вам нужно получить все ключи в словаре, вы можете использовать метод `keys`; если нужно получить все значения в словаре, то можете использовать метод `values`. У словарей также есть метод `items`, который собирает ключи и значения в бинарные группы, и с помощью этого метода очень удобно перебирать элементы словаря.

```python
person = {'name': 'Ло Хао', 'age': 25, 'height': 178}
print(person.keys())    # dict_keys(['name', 'age', 'height'])
print(person.values())  # dict_values(['Ло Хао', 25, 178])
print(person.items())   # dict_items([('name', 'Ло Хао'), ('age', 25), ('height', 178)])
for key, value in person.items():
    print(f'{key}:\t{value}')
```

Метод `update` словаря реализует операцию слияния двух словарей. Например, есть два словаря `x` и `y`, при выполнении `x.update(y)` значения, соответствующие ключам в `x`, которые совпадают с ключами в `y`, будут обновлены значениями в `y`, а пары ключ-значение, присутствующие в `y` и не присутствующие в `x`, будут добавлены непосредственно в `x`, как показано в следующем коде.

```python
person1 = {'name': 'Ло Хао', 'age': 55, 'height': 178}
person2 = {'age': 25, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}
person1.update(person2)
print(person1)  # {'name': 'Ло Хао', 'age': 25, 'height': 178, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}
```

Если вы используете Python 3.9 и выше, то также можете использовать оператор `|`, чтобы сделать то же самое, как показано в следующем коде.

```python
person1 = {'name': 'Ло Хао', 'age': 55, 'height': 178}
person2 = {'age': 25, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}
person1 |= person2
print(person1)  # {'name': 'Ло Хао', 'age': 25, 'height': 178, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}
```

Элементы можно удалить из словаря с помощью методов `pop` или `popitem`, первый из которых возвращает (получает) значение, соответствующее ключу, но вызывает ошибку `KeyError`, если указанный ключ не существует в словаре, а второй при удалении элемента возвращает (получает) бинарную пару, состоящую из ключа и значения. Метод `clear` словаря очищает словарь от всех пар ключ-значение, как показано в приведенном ниже коде.

```python
person = {'name': 'Ло Хао', 'age': 25, 'height': 178, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}
print(person.pop('age'))  # 25
print(person)             # {'name': 'Ло Хао', 'height': 178, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}
print(person.popitem())   # ('addr', '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай')
print(person)             # {'name': 'Ло Хао', 'height': 178}
person.clear()
print(person)             # {}
```

Как и в случае со списками, вы можете удалять элементы из словаря с помощью ключевого слова `del`, которое вызовет ошибку `KeyError`, если указанный ключ не индексирован на соответствующее значение, как показано ниже.

```python
person = {'name': 'Ло Хао', 'age': 25, 'height': 178, 'addr': '101, здание 1, № 62 Kehua North Road, район Ухоу, Чэнду, Китай'}
del person['age']
del person['addr']
print(person)  # {'name': 'Ло Хао', 'height': 178}
```

### Применение словарей

Давайте рассмотрим несколько простых примеров, чтобы увидеть, как мы можем использовать словари для решения некоторых практических задач.

**Пример 1**: Введите текст и подсчитайте, сколько раз встречается каждая буква алфавита, и выведите их в порядке возрастания встречаемости.

```python
sentence = input('Пожалуйста, введите текст: ')
counter = {}
for ch in sentence:
    if 'A' <= ch <= 'Z' or 'a' <= ch <= 'z':
        counter[ch] = counter.get(ch, 0) + 1
sorted_keys = sorted(counter, key=counter.get, reverse=True)
for key in sorted_keys:
    print(f'{key} встречается {counter[key]} раз.')
```

Ввод:

```
Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.
```

Вывод：

```
e встречается 27 раз.
n встречается 21 раз.
a встречается 18 раз.
i встречается 18 раз.
s встречается 16 раз.
t встречается 16 раз.
o встречается 14 раз.
h встречается 13 раз.
r встречается 10 раз.
d встречается 9 раз.
l встречается 9 раз.
g встречается 6 раз.
u встречается 6 раз.
f встречается 6 раз.
c встречается 6 раз.
y встречается 5 раз.
b встречается 5 раз.
m встречается 4 раз.
p встречается 3 раз.
w встречается 2 раз.
v встречается 2 раз.
M встречается 1 раз.
k встречается 1 раз.
x встречается 1 раз.
```

**Пример 2**: В словаре, содержащем коды и цены акций, найдите акции, цена которых превышает 100 долларов, и создайте новый словарь.

> **Пояснение**: Этот новый словарь может быть создан с помощью генеративного синтаксиса словарей.

```python
stocks = {
    'AAPL': 191.88,
    'GOOG': 1186.96,
    'IBM': 149.24,
    'ORCL': 48.44,
    'ACN': 166.89,
    'FB': 208.09,
    'SYMC': 21.29
}
stocks2 = {key: value for key, value in stocks.items() if value > 100}
print(stocks2)
```

Вывод

```
{'AAPL': 191.88, 'GOOG': 1186.96, 'IBM': 149.24, 'ACN': 166.89, 'FB': 208.09}
```

### Резюме

Словари в программах на Python очень похожи на реальные словари, позволяя нам **хранить данные** в виде пар ключ-значение, а затем **получать доступ к соответствующим значениям** через ключи. Словари - очень **выгодный тип данных для поиска данных**, но следует еще раз напомнить, что **ключи в словаре должны быть неизменяемыми**, и что списки, множества, словари и другие типы данных не могут быть использованы в качестве ключей для словарей.
