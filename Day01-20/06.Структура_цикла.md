## Структура цикла

Когда мы пишем программу, мы с большой вероятностью столкнемся с необходимостью повторить выполнение определенной инструкции или некоторого фрагмента, например, нам нужно каждые 1 секунду выводить на экран «hello, world» и продолжать выводить час. Код, показанный ниже, может сделать это один раз, если же мы хотим продолжить вывод в течение часа, нам нужно написать этот код 3600 раз, готовы ли вы это сделать?

```python
import time

print('hello, world')
time.sleep(1)
```

> **Примечание**: Функция `sleep` встроенного в Python модуля `time` позволяет программе заснуть, при этом аргумент `1` указывает на количество секунд сна, которое может быть типа `int` или `float`, например, `0.05` означает `50` миллисекунд. О функциях и модулях мы расскажем в последующих уроках.

Чтобы решить проблемы, описанные выше, мы можем использовать структуру циклов в программах на Python. Циклическая структура - это структура в программе, которая управляет повторным выполнением инструкции или нескольких инструкций. Вместо того чтобы писать код 3600 раз, вы пишете его один раз, а затем помещаете его в структуру цикла и повторяете 3600 раз. В Python есть два способа построения структуры циклов: цикл `for-in` и цикл `while`.

### Циклы `for-in`

Мы рекомендуем использовать цикл `for-in`, если точно знаем, сколько раз будет выполнен цикл, как в описанном выше сценарии с 3600 повторениями, который мы можем реализовать с помощью следующего кода. Обратите внимание, что блок кода, управляемый циклом `for-in`, также строится с помощью отступов, подобно тому, как строятся блоки кода в ветвящихся структурах. Блок кода, которым мы управляем с помощью цикла `for-in`, называется телом цикла, и обычно утверждения в теле цикла будут выполняться многократно в зависимости от настройки цикла.

```python
"""
Выводит «hello, world» каждую секунду в течение 1 часа.

Author: Ло Хао
Version: 1.0
"""
import time

for i in range(3600):
    print('hello, world')
    time.sleep(1)
```

Следует отметить, что `range(3600)` в приведенном выше коде строит диапазон от `0` до `3599`, и когда мы помещаем такой диапазон в цикл `for-in`, мы можем вынимать целые числа от `0` до `3599` по очереди, используя перед ними переменную цикла `i`, что заставит оператор в блоке `for-in` повторяться 3600 раз. Конечно, функция `range` очень гибкая, и в следующем списке приведены примеры использования функции `range`:

- `range(101)`: может использоваться для получения целых чисел в диапазоне от `0` до `100`, обратите внимание, что `101` не берется.
- `range(1, 101)`: может использоваться для получения целых чисел в диапазоне от `1` до `100`, что эквивалентно заданию левый-закрытый-правый-открытый, т. е. `[1, 101)`.
- `range(1, 101, 2)`: может использоваться для получения нечетных чисел в диапазоне от `1` до `100`, где `2` - это шаг, то есть значение, которое увеличивается каждый раз, а `101` не может быть взято.
- `range(100, 0, -2)`: может использоваться для генерации четных чисел от `100` до `1`, где `-2` - шаг, т.е. значение, которое каждый раз уменьшается, а `0` не может быть взято.

Как вы могли заметить, в приведенном выше коде переменная цикла `i` не используется ни в операции вывода, ни в операции сна. Для структуры цикла `for-in`, в которой нет необходимости использовать переменную цикла, по традиции программирования Python переменная цикла называется `_`, и модифицированный код выглядит следующим образом. Результат не сильно изменится, но вы будете выглядеть более профессионально.

```python
"""
Выводит "hello, world" каждую секунду в течение 1 часа

Author: Ло Хао
Version: 1.1
"""
import time

for _ in range(3600):
    print('hello, world')
    time.sleep(1)
```

Приведенный выше код выполняется в течение часа, и если вы хотите завершить работу программы раньше, то можете нажать кнопку Stop в окне Run в PyCharm, как показано ниже. Если вы запускаете код в командной строке или терминале, то для завершения программы можно использовать комбинацию клавиш `ctrl+c`.

<img src="res/day06/terminate_program.png" style="zoom:40%;">

Далее мы используем цикл `for-in` для реализации суммирования целых чисел от 1 до 100, т.е. $\small{\sum_{n=1}^{100}{n}}$.

```python
"""
Суммирование целых чисел от 1 до 100

Version: 1.0
Author: Ло Хао
"""
total = 0
for i in range(1, 101):
    total += i
print(total)
```

В приведенном выше коде переменная `total` служит для хранения результата суммирования. Во время цикла значение переменной цикла `i` принимается от 1 до 100, и для каждого значения переменной `i` мы выполняем оператор `total += i`, что эквивалентно оператору `total = total + i`, который реализует операцию суммирования. Таким образом, по окончании цикла мы выводим значение переменной `total`, которое является результатом накопления 5050 от 1 до 100. Обратите внимание, что оператор `print(total)` не предваряется отступом, не управляется циклом `for-in` и не будет повторяться.

Напишем еще один код для суммирования четных чисел от 1 до 100 следующим образом.   

```python
"""
Суммирование четных чисел от 1 до 100

Version: 1.0
Author: Ло Хао
"""
total = 0
for i in range(1, 101):
    if i % 2 == 0:
        total += i
print(total)
```

> **Примечание**: В цикле `for-in` выше мы использовали ветвящуюся структуру, чтобы определить, является ли переменная цикла `i` четной.

Мы также можем изменить параметры функции `range`, чтобы изменить начальное значение и диапазон на `2` для получения четных сумм от 1 до 100 в более простом коде.

```python
"""
Суммирование четных чисел от 1 до 100

Version: 1.1
Author: Ло Хао
"""
total = 0
for i in range(2, 101, 2):
    total += i
print(total)
```

Конечно, более простой способ сделать это - использовать встроенную в Python функцию `sum`, которая устраняет необходимость в циклической структуре.

```python
"""
Суммирование четных чисел от 1 до 100

Version: 1.2
Author: Ло Хао
"""
print(sum(range(2, 101, 2)))
```

### Цикл while

Если вы хотите построить структуру цикла, но не уверены, сколько раз он будет повторяться, рекомендуем использовать цикл `while`. Когда значение булевого выражения равно `True`, операторы в теле цикла (блок кода под оператором `while`, сохраняющий тот же отступ) повторяются, а когда значение выражения равно `False`, цикл завершается.

Мы будем использовать цикл `while` для суммирования целых чисел от 1 до 100, как показано в следующем коде.

```python
"""
Суммирование целых чисел от 1 до 100

Version: 1.1
Author: Ло Хао
"""
total = 0
i = 1
while i <= 100:
    total += i
    i += 1
print(total)
```

По сравнению с циклом `for-in`, в приведенном выше коде мы добавили переменную `i` перед началом цикла, которую мы используем для управления циклом, поэтому за `while` следует условие `i <= 100`. В теле цикла `while` нам нужно увеличить значение переменной `i` в дополнение к накоплению, поэтому мы добавили оператор `i += 1`, чтобы значение `i` принимало значения 1, 2, 3, ...... по очереди до 101. Когда `i` становится 101, условие цикла `while` перестает выполняться, и код выходит из цикла `while`, в этот момент мы выводим значение переменной `total`, которое является результатом суммирования от 1 до 100, тоесть `5050`.

Если мы хотим суммировать четные числа от 1 до 100, то должны немного модифицировать приведенный выше код.

```python
"""
Суммирование четных чисел от 1 до 100

Version: 1.3
Author: Ло Хао
"""
total = 0
i = 2
while i <= 100:
    total += i
    i += 2
print(total)
```

### break и continue

Что произойдет, если установить условие цикла `while` в `True`, то есть сделать условие постоянным? Давайте посмотрим на следующий код, который по-прежнему использует `while` для построения структуры цикла, вычисляющего сумму четных чисел от 1 до 100.

```python
"""
Суммирование четных чисел от 1 до 100

Version: 1.4
Author: Ло Хао
"""
total = 0
i = 2
while True:
    total += i
    i += 2
    if i > 100:
        break
print(total) 
```

В приведенном выше коде используется `while True` для построения цикла с постоянным условием, а это означает, что цикл не завершится без специальной обработки, которую часто называют "мертвой петлей". Для того, чтобы остановить цикл после того, как значение `i` превысит 100, мы используем ключевое слово `break`, которое завершает выполнение структуры цикла. Обратите внимание, что `break` может завершить только тот цикл, в котором он находится, что важно учитывать при использовании вложенных циклов, о которых мы поговорим позже. Помимо `break`, в структуре цикла может использоваться еще одно ключевое слово `continue`, с помощью которого можно прервать последующий код текущего цикла и позволить циклу перейти на следующий круг, как показано в следующем коде.

```python
"""
Суммирование четных чисел от 1 до 100

Version: 1.5
Author: Ло Хао
"""
total = 0
for i in range(1, 101):
    if i % 2 != 0:
        continue
    total += i
print(total)
```

> **Примечание**: Приведенный выше код использует ключевое слово `continue`, чтобы пропустить случай, когда `i` нечетно, и выполняет `total += i` только в том случае, если `i` четно.

### Вложенные структуры циклов

Как и ветвящиеся структуры, структуры циклов могут быть вложенными, это означает, что циклы также могут быть построены внутри структуры циклов. Следующий пример демонстрирует, как вложенный цикл может быть использован для вывода таблицы результатов умножения (таблица 9-9-9).

```python
"""
Распечатать таблицу умножения

Version: 1.0
Author: Ло Хао
"""
for i in range(1, 10):
    for j in range(1, i + 1):
        print(f'{i}×{j}={i * j}', end='\t')
    print()
```

В приведенном выше коде цикл `for-in` снова используется в теле цикла `for-in`, где внешний цикл используется для управления выводом, который генерирует `i` строк, а внутренний цикл - для управления выводом `j` столбцов в строке. Очевидно, что выходом внутреннего цикла `for-in` является целая строка в таблице результатов умножения. Поэтому по завершении внутреннего цикла мы используем `print()`, чтобы осуществить перевод строки, так что следующий вывод будет перезапущен на отдельной строке, и окончательный вывод будет показан ниже.

```
1×1=1	
2×1=2	2×2=4	
3×1=3	3×2=6	3×3=9	
4×1=4	4×2=8	4×3=12	4×4=16	
5×1=5	5×2=10	5×3=15	5×4=20	5×5=25	
6×1=6	6×2=12	6×3=18	6×4=24	6×5=30	6×6=36	
7×1=7	7×2=14	7×3=21	7×4=28	7×5=35	7×6=42	7×7=49	
8×1=8	8×2=16	8×3=24	8×4=32	8×5=40	8×6=48	8×7=56	8×8=64	
9×1=9	9×2=18	9×3=27	9×4=36	9×5=45	9×6=54	9×7=63	9×8=72	9×9=81
```

### Применение циклических структур

#### Пример 1: Определение простого числа

Требование: введите целое положительное число больше 1 и определите, является ли оно простым.

> **Подсказка**: Простое число - это целое число больше 1, которое делится только на 1 и на само себя. Например, для целого положительного числа $\small{n}$ мы можем определить, является ли оно простым или нет, найдя коэффициент $\small{n}$ между 2 и $\small{n - 1}$. Конечно, цикл не обязательно должен начинаться с 2 и заканчиваться на $\small{n - 1}$, потому что для целых положительных чисел больше 1 коэффициенты должны идти парами, так что цикл может заканчиваться на $\small{\sqrt{n}}$.

```python
"""
Введите целое положительное число больше 1 чтобы определить, является ли оно простым.

Version: 1.0
Author: Ло Хао
"""
num = int(input('Пожалуйста, введите целое положительное число: '))
end = int(num ** 0.5)
is_prime = True
for i in range(2, end + 1):
    if num % i == 0:
        is_prime = False
        break
if is_prime:
    print(f'{num} простое число')
else:
    print(f'{num} непростое число')
```

> **Пояснение**: В приведенном выше коде мы использовали булеву переменную `is_prime`, сначала мы присваиваем ей значение `True`, предполагая, что `num` - простое число; затем мы ищем коэффициент `num` в диапазоне от 2 до `num ** 0.5`, и если мы находим коэффициент `num`, то это значит что число не является простым, и в этот момент мы присваиваем `is_prime` значение `False`, используя ключевое слово `break` для завершения структуры цикла; наконец, мы используем `is_prime` в зависимости от того, является ли оно `True` или `False`; мы даем выводим данные в зависимости от того, является ли значение `is_prime` `True` или `False`.

#### Пример 2: Наибольший общий делитель

Требование: Учитывая два целых положительных числа, больших 0, найдите наибольший общий делитель этих двух чисел.

> **Подсказка**: Наибольший общий делитель двух чисел - это наибольший из общих множителей этих чисел.

```python
"""
Введите два целых положительных числа, чтобы найти их наибольший общий делитель.

Version: 1.0
Author: Ло Хао
"""
x = int(input('x = '))
y = int(input('y = '))
for i in range(x, 0, -1):
    if x % i == 0 and y % i == 0:
        print(f'Наибольший общий делитель: {i}')
        break
```

> **Примечание**: В приведенном выше коде значения переменных цикла `for-in` расположены в порядке убывания, так что найденный множитель `i`, который делит и `x`, и `y`, является наибольшим общим делителем `x` и `y`, и в этот момент мы завершаем цикл командой `break`. Если `x` и `y` взаимно простые, то цикл будет выполняться до тех пор, пока `i` не станет равным 1, поскольку 1 является множителем всех положительных целых чисел, а наибольший общий делитель `x` и `y` равен 1.

Нахождение наибольшего общего делителя с помощью приведенного выше кода проблематично с точки зрения эффективности выполнения. Если значение `x` равно `99999999999998`, а значение `y` равно `9999999999999999`, то очевидно, что эти два числа взаимно простые, а наибольший общий делитель равен 1. Однако если использовать приведенный выше код, то цикл повторится `999999999999999998` раз, что обычно неприемлемо. Мы можем использовать алгоритм Евклида для нахождения наибольшего общего делителя, который поможет нам получить желаемый результат быстрее, как показано в коде ниже.

```python
"""
Введите два целых положительных числа, чтобы найти их наибольший общий делитель.

Version: 1.1
Author: Ло Хао
"""
x = int(input('x = '))
y = int(input('y = '))
while y % x != 0:
    x, y = y % x, x
print(f'Наибольший общий делитель: {x}')
```

> **Примечание**: Методы и шаги решения задачи можно назвать алгоритмами, для одной и той же задачи мы можем разработать разные алгоритмы, разные алгоритмы по занимаемому пространству и эффективности реализации различаются, и эти различия представляют собой преимущества и недостатки алгоритма. Вы можете сравнить два приведенных выше абзаца, чтобы понять, почему мы говорим, что алгоритм Евклида - лучший выбор. Оператор `x, y = y % x, x` в приведенном выше коде означает, что значение `y % x` присваивается `x`, а исходное значение `x` присваивается `y`.

#### Пример 3: Игра "Угадай число"

Требования: Компьютер выдает случайное число от 1 до 100, игрок вводит число, которое он угадал, компьютер выдает соответствующие подсказки "больше", "меньше" или "угадал", если игрок угадал число; компьютер предлагает пользователю угадать его определенное количество раз.

```python
"""
Игра "Угадай число"

Version: 1.0
Author: Ло Хао
"""
import random

answer = random.randrange(1, 101)
counter = 0
while True:
    counter += 1
    num = int(input('Пожалуйста, введите число: '))
    if num < answer:
        print('Больше.')
    elif num > answer:
        print('Меньше.')
    else:
        print('Именно так.')
        break
print(f'Всего вы сделали {counter} попыток.')
```

> **Примечание**: В приведенном выше коде используется `import random` для импорта модуля `random` стандартной библиотеки Python, функция `randrange` которого помогает нам генерировать случайные числа в диапазоне от 1 до 100 (исключая 100). Переменная `counter` используется для отслеживания того, сколько раз был выполнен цикл, т.е. сколько раз пользователь угадывал, и значение `counter` увеличивается на единицу для каждого цикла.

### Резюме

Изучение ветвлений и циклов в Python позволяет нам решать множество реальных задач. Как вы узнали из этого урока, вы уже должны знать, что для построения циклических структур можно использовать ключевые слова `for` и `while`. **Обычно мы используем циклы** `for` **, если заранее знаем, сколько раз структура цикла будет повторяться; Если количество повторений структуры цикла определить невозможно, мы можем использовать циклы** `while` **. Кроме того, мы можем использовать** `break` **в структуре цикла для его завершения, или ключевое слово** `continue` **чтобы позволить структуре цикла перейти непосредственно к следующему циклу**.