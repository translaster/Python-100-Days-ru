## Часто используемые структуры данных - множества

После знакомства со списками и кортежами давайте узнаем о контейнерном типе данных, который называется множеством. Слово "множество" не будет для вас незнакомым, поскольку это понятие встречается в учебниках по математике. Если **взять некоторый набор определенных, различимых вещей как единое целое**, то это целое будет множеством, а отдельные вещи в нем называются **элементами** множества. Как правило, множества должны удовлетворять следующим требованиям:

1. **Неупорядоченность**: в множестве каждый элемент имеет одинаковый статус, и элементы неупорядочены друг относительно друга.
2. **Взаимное несходство**: множество, в котором любые два элемента не являются одинаковыми, т.е. элементы могут встречаться в множестве только один раз.
3. **Детерминизм**: если дано множество и произвольный элемент, то элемент либо принадлежит множеству, либо не принадлежит, либо одно, либо другое, двусмысленность не допускается.

Множества в программах на Python принципиально не отличаются от математических множеств; необходимо подчеркнуть описанные выше неупорядоченность и взаимное неподобие. Неупорядоченность означает, что элементы в множестве не имеют некоторого порядка, как элементы в столбце, и к любому элементу можно получить доступ с помощью операции индексирования; **множества не поддерживают операции индексирования**. Кроме того, взаимная однозначность множества диктует, что **множества не могут иметь дублирующихся элементов**, и это то, что отличает множества от списков; мы не можем добавлять дублирующиеся элементы в множества. Тип множество обязательно поддерживают операции принадлежности `in` и `not in`, что позволяет определить, принадлежит ли элемент множеству или нет, что является детерминизмом упомянутого выше множества. **Операция принадлежности множества лучше, чем операция принадлежности списка, с точки зрения производительности**, которая определяется базовыми свойствами хранения множества, которые мы пока не будем обсуждать, а просто запомним этот вывод.

> **Пояснение**: в основе множества лежит хэш-хранилище. Читатели, которые не понимают что такое хэш-хранилище, могут ознакомиться с объяснением [хэш-таблиц](https://www.hello-algo.com/chapter_hashing/) на сайте "Hello Algorithm". Спасибо автору за дух открытого исходного кода.

### Создание множеств

В Python вы можете создать множество, используя синтаксис литерала `{}`. `{}` должен содержать хотя бы один элемент, потому что `{}` без элемента - это не пустое множество, а пустой словарь, который мы рассмотрим в следующем уроке. Конечно, вы также можете создать множество с помощью встроенной функции Python `set`. `set` - это не совсем функция, а скорее конструктор, создающий объект множество, о котором мы поговорим позже в этом уроке по объектно-ориентированному программированию. Мы можем использовать функцию `set` для создания пустого множества, а можем использовать ее для преобразования других последовательностей в множества, например, `set('hello')` приведет к созданию множества, содержащего `4` символа (повторяющийся символ `l` будет встречаться в множестве только один раз). Помимо этих двух способов, вы также можете использовать генеративный синтаксис для создания множеств, как мы делали это ранее со списками, используя подобный синтаксис.

```python
set1 = {1, 2, 3, 3, 3, 2}
print(set1)

set2 = {'banana', 'pitaya', 'apple', 'apple', 'banana', 'grape'}
print(set2)

set3 = set('hello')
print(set3)

set4 = set([1, 2, 2, 3, 3, 3, 2, 1])
print(set4)

set5 = {num for num in range(1, 20) if num % 3 == 0 or num % 7 == 0}
print(set5)
```

Напоминаю, что элементы множества должны быть типа `hashable`, под типом `hashable` я подразумеваю тип данных, для которого может быть вычислен хэш-код, обычно неизменяемые типы имеют тип `hashable`, такие как целые числа (`int`), числа с плавающей запятой (`float`), булевы числа (`bool`), строки (`str`), кортежи (`tuples`) и так далее. Ни один из изменяемых типов не является `hashable`, потому что изменяемые типы не могут вычислять детерминированный хэш-код, поэтому их нельзя помещать в множества. Например, мы не можем использовать список в качестве элемента множества; аналогично, множество не может быть использовано в качестве элемента множества, поскольку само множество является изменяемым типом. Мы можем создавать вложенные списки (элементы списка также являются списками), но мы не можем создавать вложенные множества, что необходимо учитывать при работе с ними.

> **Теплый совет**: Если вы не понимаете концепций хэш-кодов и хэш-хранилищ, упомянутых выше, можете пока отложить их в сторону, поскольку это не повлияет на вашу способность продолжать изучать и использовать язык Python. Конечно, если вы изучаете информатику, вам вряд ли простят непонимание хэш-хранилищ, поэтому поспешите наверстать упущенное.

### Перебор элементов

Мы можем использовать функцию `len`, чтобы узнать количество элементов в множестве, но мы не можем перебирать элементы с помощью операций индексирования, поскольку элементы множества не расположены в определенном порядке. Конечно, для обхода элементов множества мы можем использовать цикл `for-in`, как показано в приведенном ниже коде.

```python
set1 = {'Python', 'C++', 'Java', 'Kotlin', 'Swift'}
for elem in set1:
    print(elem)
```

> **Подсказка**: взгляните на результаты работы приведенного выше кода и оцените неупорядоченность множеств по порядку вывода слов.

### Операции над множествами

Python предоставляет очень богатый набор операций для множеств, включая операции принадлежности, пересечения, объединения, разности и сравнения (равенство, подмножество, надмножество).

#### Операции принадлежности

Вы можете проверить, находится ли элемент в множестве или нет, используя операторы `in` и `not in`, как показано в следующем коде.

```python
set1 = {11, 12, 13, 14, 15}
print(10 in set1)      # False 
print(15 in set1)      # True
set2 = {'Python', 'Java', 'C++', 'Swift'}
print('Ruby' in set2)  # False
print('Java' in set2)  # True
```

#### Бинарные операции

Набор бинарных операций в основном относится к пересечению, объединению, разности, симметричных разностей и других операций над множествами, эти операции могут быть достигнуты с помощью операторов, а также с помощью набора типов методов для достижения кода, показанного ниже.

<img src="res/day12/set_operations.png" style="zoom:50%;">

```python
set1 = {1, 2, 3, 4, 5, 6, 7}
set2 = {2, 4, 6, 8, 10}

# Пересечение (символ ∩) (теория множеств)
print(set1 & set2)                      # {2, 4, 6}
print(set1.intersection(set2))          # {2, 4, 6}

# Конкатенация И
print(set1 | set2)                      # {1, 2, 3, 4, 5, 6, 7, 8, 10}
print(set1.union(set2))                 # {1, 2, 3, 4, 5, 6, 7, 8, 10}

# Разность
print(set1 - set2)                      # {1, 3, 5, 7}
print(set1.difference(set2))            # {1, 3, 5, 7}

# Симметрия
print(set1 ^ set2)                      # {1, 3, 5, 7, 8, 10}
print(set1.symmetric_difference(set2))  # {1, 3, 5, 7, 8, 10}
```

Как видно из приведенного выше кода, оператор `&` и метод `intersection` делают совершенно одинаковые вещи для пересечения двух множеств, и использование оператора, очевидно, более интуитивно понятно и коротко. Следует отметить, что бинарные операции над множествами также можно комбинировать с операциями присваивания, образуя составные операции присваивания, например: `set1 |= set2` эквивалентно `set1 = set1 | set2`, и `|=` работает так же, как `update`; `set1 &= set2` эквивалентно `set1 = set1 & set2`, и `&=` работает так же, как `intersection`. Метод, аналогичный методу `&=` - это `intersection_update`, код которого показан ниже.

```python
set1 = {1, 3, 5, 7}
set2 = {2, 4, 6}
set1 |= set2
# set1.update(set2)
print(set1)  # {1, 2, 3, 4, 5, 6, 7}
set3 = {3, 6, 9}
set1 &= set3
# set1.intersection_update(set3)
print(set1)  # {3, 6}
set2 -= set1
# set2.difference_update(set1)
print(set2)  # {2, 4}
```

#### Операции сравнения

Два множества можно сравнить с помощью операций `==` и `!==` Если элементы двух множеств одинаковы, то результатом сравнения `==` будет `True`, в противном случае - `False`. Множество `A` называется подмножеством множества `B`, если любой из элементов множества `A` является элементом множества `B`, то есть для $\small{\forall{a} \in {A}}$, и $\small{{a} \in {B}}$, то $\small{{A} \subseteq {B}}$, `A` является подмножеством `B`. и, наоборот, можно сказать, что `B` является супермножеством `A`. Если `A` является подмножеством `B` и `A` не равно `B`, то `A` является истинным подмножеством `B`. Python предоставляет операторы для определения подмножеств и супермножеств для множеств - это хорошо знакомые операторы `<`, `<=`, `>` и `>=`. Конечно, мы также можем определить отношения между множествами, используя методы множеств `issubset` и `issuperset`, как показано в коде ниже.

```python
set1 = {1, 3, 5}
set2 = {1, 2, 3, 4, 5}
set3 = {5, 4, 3, 2, 1}

print(set1 < set2)   # True
print(set1 <= set2)  # True
print(set2 < set3)   # False
print(set2 <= set3)  # True
print(set2 > set1)   # True
print(set2 == set3)  # True

print(set1.issubset(set2))    # True
print(set2.issuperset(set1))  # True
```

> **Примечание**: В приведенном выше коде `set1 < set2` определяет, является ли `set1` истинным подмножеством `set2`, `set1 <= set2` определяет, является ли `set1` подмножеством `set2`, а `set2 > set1` определяет, является ли `set2` надмножеством `set1`. Конечно, мы также можем определить, является ли `set1` подмножеством `set2` по `set1.issubset(set2)`; и является ли `set2` супермножеством `set1` по `set2.issuperset(set1)`.

### Методы множеств

Как мы только что сказали, множества в Python - это изменяемый тип данных и мы можем добавлять элементы в множества или удалять их оттуда с помощью методов множеств.

```python
set1 = {1, 10, 100}

# Добавление элементов
set1.add(1000)
set1.add(10000)
print(set1)  # {1, 100, 1000, 10, 10000}

# Удаление элементов
set1.discard(10)
if 100 in set1:
    set1.remove(100)
print(set1)  # {1, 1000, 10000}

# Очистка множества
set1.clear()
print(set1)  # set()
```

> **Примечание**: Метод `remove`, удаляющий элемент, выдаёт ошибку `KeyError`, если элемент не существует, поэтому в приведенном выше коде мы сначала определяем, есть ли элемент в множестве, используя операцию принадлежности. Множества также имеют метод `pop`, удаляющий случайный элемент из коллекции, который возвращает (получает) удаленный элемент при его удалении, в то время как методы `remove` и `discard` просто удаляют элемент и не возвращают (получают) удаленный элемент.

Множество также имеет метод `isdisjoint`, который определяет, имеют ли два множества одинаковый элемент, если нет, то метод возвращает `True`, в противном случае метод возвращает `False`, как показано в коде ниже.

```python
set1 = {'Java', 'Python', 'C++', 'Kotlin'}
set2 = {'Kotlin', 'Swift', 'Java', 'Dart'}
set3 = {'HTML', 'CSS', 'JavaScript'}
print(set1.isdisjoint(set2))  # False
print(set1.isdisjoint(set3))  # True
```

### Неизменяемые множества

В Python также есть неизменяемый тип множества, называемый `frozenset`. Набор `set` отличается от `frozenset` так же, как `list` отличается от `tuple`; `frozenset` можно использовать в качестве элемента в `set`, потому что он неизменяем и может вычислять хэш-коды. В остальном `frozenset` такой же, как и `set`, за исключением того, что он не может добавлять или удалять элементы, и следующий код просто демонстрирует использование `frozenset`.

```python
fset1 = frozenset({1, 3, 5, 7})
fset2 = frozenset(range(1, 6))
print(fset1)          # frozenset({1, 3, 5, 7})
print(fset2)          # frozenset({1, 2, 3, 4, 5})
print(fset1 & fset2)  # frozenset({1, 3, 5})
print(fset1 | fset2)  # frozenset({1, 2, 3, 4, 5, 7})
print(fset1 - fset2)  # frozenset({7})
print(fset1 < fset2)  # False
```

### Резюме

**Множество в Python - это неупорядоченный контейнер**, в котором **дублирование элементов не допускаются**, а элементы должны иметь тип `hashable` из-за использования хэш-хранилища. Самое большое различие между множеством и списком заключается в том, что **множества неупорядочены**, поэтому **для множества недоступны операции индексирования**, но при этом они могут выполнять бинарные операции, такие как пересечение, объединение, разность и т.д., а также могут быть проверены на наличие надмножеств, подмножеств и других отношений через реляционные операторы.