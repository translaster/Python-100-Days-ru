## Часто используемые структуры данных списка-1

Прежде чем мы начнем этот урок, мы сначала дадим вам задачу по программированию: 6000 раз бросить кубик, подсчитать, сколько раз появляется каждая точка. Эта задача должна быть очень простой для вас, мы можем использовать от 1 до 6 равномерно распределенных случайных чисел для имитации броска кубика, а затем использовать 6 переменных для записи количества раз появления каждого количества очков, я считаю, что благодаря предыдущему исследованию мы можем написать следующий код более гладко.

```python
"""
Бросить кубик 6000 раз и подсчитать, сколько раз встречается каждое количество очков.

Author: Ло Хао
Version: 1.0
"""
import random

f1 = 0
f2 = 0
f3 = 0
f4 = 0
f5 = 0
f6 = 0
for _ in range(6000):
    face = random.randrange(1, 7)
    if face == 1:
        f1 += 1
    elif face == 2:
        f2 += 1
    elif face == 3:
        f3 += 1
    elif face == 4:
        f4 += 1
    elif face == 5:
        f5 += 1
    else:
        f6 += 1
print(f'1 выпадала {f1} раз')
print(f'2 выпадала {f2} раз')
print(f'3 выпадала {f3} раз')
print(f'4 выпадала {f4} раз')
print(f'5 выпадала {f5} раз')
print(f'6 выпадала {f6} раз')
```

Не нужно говорить, насколько "уродлив" приведенный выше код. Конечно, еще ужаснее то, что если мы хотим перевернуть два или более очков, а затем подсчитать, сколько раз встречается каждое количество точек, то нам нужно определить больше переменных и написать больше ветвящихся структур, что заставляет нас всех чувствовать себя больными на всю голову, когда мы думаем об этом. В этот момент, я уверен, у вас возникает вопрос: есть ли способ использовать одну переменную для хранения нескольких данных, и есть ли способ манипулировать несколькими частями данных с помощью одного фрагмента кода? Ответ - да. В Python вы можете сохранять и манипулировать несколькими частями данных с помощью контейнерных переменных, и для начала мы познакомим вас с новым типом данных `list`.

### Создание списков

В Python **список - это последовательность данных, состоящая из ряда элементов, расположенных в определенном порядке**, а это значит, что если мы определим переменную типа list, **мы сможем использовать ее для хранения нескольких частей данных**. В Python списки могут быть определены с помощью синтаксиса литералов `[]`, где несколько элементов в списке разделяются запятыми, как показано в коде ниже.

```python
items1 = [35, 12, 99, 68, 55, 35, 87]
items2 = ['Python', 'Java', 'Go', 'Kotlin']
items3 = [100, 12.3, 'Python', True]
print(items1)  # [35, 12, 99, 68, 55, 35, 87]
print(items2)  # ['Python', 'Java', 'Go', 'Kotlin']
print(items3)  # [100, 12.3, 'Python', True]
```

> **Примечание**: Списки могут иметь дублирующиеся элементы, например, `35` в `items1`; списки могут иметь элементы разных типов, например, `int`, `float`, `str` и `bool` в `items3`, но мы обычно не рекомендуем помещать элементы разных типов в один список, в основном потому, что это это крайне неудобно для манипуляций.

Мы можем использовать функцию `type`, чтобы узнать тип переменной, так что если вам интересно, то можете сами посмотреть, какого типа переменная `items1` выше. Поскольку списки могут содержать несколько элементов, они являются контейнерным типом данных, поэтому, когда мы называем переменную типа list, имя переменной обычно представляет собой слово в форме множественного числа.

Кроме того, вы можете превращать другие последовательности в списки с помощью встроенной в Python функции `list`. Если быть точным, `list` - это не обычная функция, а конструктор, создающий объект-список, а с понятиями объектов и конструкторов вы познакомитесь позже в этом курсе.

```python
items4 = list(range(1, 10))
items5 = list('hello')
print(items4)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(items5)  # ['h', 'e', 'l', 'l', 'o']
```

> **Описание**: `range(1, 10)` создает последовательность целых чисел от `1` до `9`, которая, будучи переданной конструктору `list`, создает список целых чисел от `1` до `9`. Строки - это последовательности символов, и `list('hello')` выше создает объект списка, используя символы строки `hello` в качестве элементов списка.

### Операции над списками

Мы можем использовать оператор `+` для реализации объединения двух списков, операция объединения объединит элементы двух списков в один, код показан ниже.

```python
items5 = [35, 12, 99, 45, 66]
items6 = [45, 58, 29]
items7 = ['Python', 'Java', 'JavaScript']
print(items5 + items6)  # [35, 12, 99, 45, 66, 45, 58, 29]
print(items6 + items7)  # [45, 58, 29, 'Python', 'Java', 'JavaScript']
items5 += items6
print(items5)  # [35, 12, 99, 45, 66, 45, 58, 29]
```

Мы можем использовать оператор `*` для реализации операции повторения для списков, оператор `*` повторяет элемент списка указанное количество раз, мы добавим две строки в приведенный выше код, как показано ниже.

```python
print(items6 * 3)  # [45, 58, 29, 45, 58, 29, 45, 58, 29]
print(items7 * 2)  # ['Python', 'Java', 'JavaScript', 'Python', 'Java', 'JavaScript']
```

Мы можем использовать оператор `in` или `not in`, чтобы определить, находится ли элемент в списке или нет, и добавляем еще две строки к приведенному выше коду, как показано ниже.

```python
print(29 in items6)  # True
print(99 in items6)  # False
print('C++' not in items7)     # True
print('Python' not in items7)  # False
```

Поскольку в списке есть несколько элементов, и они располагаются в списке в определенном порядке, когда мы хотим манипулировать элементом в списке, мы можем использовать оператор `[]` для доступа к элементу, указав его позицию в `[]`, что известно как операция индексирования. Следует отметить, что позиция элемента в `[]` может быть целым числом от `0` до `N - 1` или от `-1` до `-N`, которые известны как прямой и обратный индексы соответственно, где `N` обозначает количество элементов списка. Для прямого индекса `[0]` получает доступ к первому элементу списка, а `[N - 1]` - к последнему элементу; для обратного индекса `[-1]` получает доступ к последнему элементу списка, а `[-N]` - к первому элементу, как показано в приведенном ниже коде.

```python
items8 = ['apple', 'waxberry', 'pitaya', 'peach', 'watermelon']
print(items8[0])   # apple
print(items8[2])   # pitaya
print(items8[4])   # watermelon
items8[2] = 'durian'
print(items8)      # ['apple', 'waxberry', 'durian', 'peach', 'watermelon']
print(items8[-5])  # 'apple'
print(items8[-4])  # 'waxberry'
print(items8[-1])  # watermelon
items8[-4] = 'strawberry'
print(items8)      # ['apple', 'strawberry', 'durian', 'peach', 'watermelon']
```

При использовании операций индексирования следует избегать выхода индекса за пределы диапазона. Для приведенного выше `items8`, если мы обратимся к `items8[5]` или `items8[-6]`, это вызовет ошибку `IndexError`, которая приведет к ошибке программы, и выдаст соответствующее сообщение об ошибке - *list index out of range*, что переводится как "индекс массива вне диапазона". Причина в том, что для списка `items8`, состоящего всего из пяти элементов, допустимыми прямыми индексами являются `0` - `4`, а допустимыми обратными индексами - `-1` - `-5`.

Если вы хотите получить доступ к нескольким элементам списка за один раз, то можете использовать нарезку. Slicing - это оператор вида `[start:end:stride]`, где `start` представляет начальную позицию элемента списка, к которому осуществляется доступ, `end` представляет конечную позицию элемента списка (элемент в конечной позиции недоступен), а `stride` представляет промежуток, который является простым приращением позиции, например, если мы обращаемся к первому элементу по адресу `start`, то второй элемент находится по адресу `start + stride`, но, конечно, `start + stride` меньше, чем `end`. Добавим к приведенному выше коду следующий оператор для доступа к элементам списка с помощью оператора slice.

```python
print(items8[1:3:1])     # ['strawberry', 'durian']
print(items8[0:3:1])     # ['apple', 'strawberry', 'durian']
print(items8[0:5:2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2:1])   # ['strawberry', 'durian']
print(items8[-2:-6:-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

> **ПОМНИТЕ**: Вы можете посмотреть на последнюю строку в приведенном выше коде и подумать о том, как операция нарезки обращается к элементам, когда интервал отрицателен.

Если значение `start` равно `0`, то его можно опустить при использовании оператора slice; если значение `end` равно `N`, что представляет собой количество элементов в списке, то его можно опустить при использовании оператора slice; и если значение `stride` равно `1`, то его также можно опустить при использовании данного оператора. Таким образом, следующий код делает то же самое, что и код выше.

```python
print(items8[1:3])     # ['strawberry', 'durian']
print(items8[:3:1])    # ['apple', 'strawberry', 'durian']
print(items8[::2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2])   # ['strawberry', 'durian']
print(items8[-2::-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

事实上，我们还可以通过切片操作修改列表中的元素，例如我们给上面的代码再加上一行，大家可以看看这里的输出。

```python
items8[1:3] = ['x', 'o']
print(items8)  # ['apple', 'x', 'o', 'peach', 'watermelon']
```

两个列表还可以做关系运算，我们可以比较两个列表是否相等，也可以给两个列表比大小，代码如下所示。

```python
nums1 = [1, 2, 3, 4]
nums2 = list(range(1, 5))
nums3 = [3, 2, 1]
print(nums1 == nums2)  # True
print(nums1 != nums2)  # False
print(nums1 <= nums3)  # True
print(nums2 >= nums3)  # False
```

> **说明**：上面的`nums1`和`nums2`对应元素完全相同，所以`==`运算的结果是`True`。`nums2`和`nums3`的比较，由于`nums2`的第一个元素`1`小于`nums3`的第一个元素`3`，所以`nums2 >= nums3`比较的结果是`False`。两个列表的关系运算在实际工作并不那么常用，如果实在不理解就跳过吧，不用纠结。

### 元素的遍历

如果想逐个取出列表中的元素，可以使用`for-in`循环的，有以下两种做法。

方法一：在循环结构中通过索引运算，遍历列表元素。

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for index in range(len(languages)):
    print(languages[index])
```

输出：

```
Python
Java
C++
Kotlin
```

> **说明**：上面的`len`函数可以获取列表元素的个数`N`，而`range(N)`则构成了从`0`到`N-1`的范围，刚好可以作为列表元素的索引。

方法二：直接对列表做循环，循环变量就是列表元素的代表。

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for language in languages:
    print(language)
```

输出：

```
Python
Java
C++
Kotlin
```

### 总结

讲到这里，我们可以用列表的知识来重构上面“掷色子统计每种点数出现次数”的代码。

```python
"""
将一颗色子掷6000次，统计每种点数出现的次数

Author: Ло Хао
Version: 1.1
"""
import random

counters = [0] * 6
# 模拟掷色子记录每种点数出现的次数
for _ in range(6000):
    face = random.randrange(1, 7)
    counters[face - 1] += 1
# 输出每种点数出现的次数
for face in range(1, 7):
    print(f'{face}点出现了{counters[face - 1]}次')
```

上面的代码中，我们用`counters`列表中的六个元素分别表示 1 到 6 点出现的次数，最开始的时候六个元素的值都是 0。接下来，我们用 1 到 6 均匀分布的随机数模拟掷色子，如果摇出 1 点，`counters[0]`的值加 1，如果摇出 2 点，`counters[1]`的值加 1，以此类推。大家感受一下，由于使用了列表类型加上循环结构，我们对数据的处理是批量性的，这就使得修改后的代码比之前的代码要简单优雅得多。
