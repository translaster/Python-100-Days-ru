## Часто используемые структуры данных списка-1

Прежде чем мы начнем этот урок, мы сначала дадим вам задачу по программированию: 6000 раз бросить кубик, подсчитать, сколько раз появляется каждая точка. Эта задача должна быть очень простой для вас, мы можем использовать от 1 до 6 равномерно распределенных случайных чисел для имитации броска кубика, а затем использовать 6 переменных для записи количества раз появления каждого количества очков, я считаю, что благодаря предыдущему исследованию мы можем написать следующий код более гладко.

```python
"""
Бросить кубик 6000 раз и подсчитать, сколько раз встречается каждое количество очков.

Author: Ло Хао
Version: 1.0
"""
import random

f1 = 0
f2 = 0
f3 = 0
f4 = 0
f5 = 0
f6 = 0
for _ in range(6000):
    face = random.randrange(1, 7)
    if face == 1:
        f1 += 1
    elif face == 2:
        f2 += 1
    elif face == 3:
        f3 += 1
    elif face == 4:
        f4 += 1
    elif face == 5:
        f5 += 1
    else:
        f6 += 1
print(f'1 выпадала {f1} раз')
print(f'2 выпадала {f2} раз')
print(f'3 выпадала {f3} раз')
print(f'4 выпадала {f4} раз')
print(f'5 выпадала {f5} раз')
print(f'6 выпадала {f6} раз')
```

Не нужно говорить, насколько "уродлив" приведенный выше код. Конечно, еще ужаснее то, что если мы хотим перевернуть два или более очков, а затем подсчитать, сколько раз встречается каждое количество точек, то нам нужно определить больше переменных и написать больше ветвящихся структур, что заставляет нас всех чувствовать себя больными на всю голову, когда мы думаем об этом. В этот момент, я уверен, у вас возникает вопрос: есть ли способ использовать одну переменную для хранения нескольких данных, и есть ли способ манипулировать несколькими частями данных с помощью одного фрагмента кода? Ответ - да. В Python вы можете сохранять и манипулировать несколькими частями данных с помощью контейнерных переменных, и для начала мы познакомим вас с новым типом данных `list`.

### Создание списков

В Python **список - это последовательность данных, состоящая из ряда элементов, расположенных в определенном порядке**, а это значит, что если мы определим переменную типа list, **мы сможем использовать ее для хранения нескольких частей данных**. В Python списки могут быть определены с помощью синтаксиса литералов `[]`, где несколько элементов в списке разделяются запятыми, как показано в коде ниже.

```python
items1 = [35, 12, 99, 68, 55, 35, 87]
items2 = ['Python', 'Java', 'Go', 'Kotlin']
items3 = [100, 12.3, 'Python', True]
print(items1)  # [35, 12, 99, 68, 55, 35, 87]
print(items2)  # ['Python', 'Java', 'Go', 'Kotlin']
print(items3)  # [100, 12.3, 'Python', True]
```

> **Примечание**: Списки могут иметь дублирующиеся элементы, например, `35` в `items1`; списки могут иметь элементы разных типов, например, `int`, `float`, `str` и `bool` в `items3`, но мы обычно не рекомендуем помещать элементы разных типов в один список, в основном потому, что это это крайне неудобно для манипуляций.

Мы можем использовать функцию `type`, чтобы узнать тип переменной, так что если вам интересно, то можете сами посмотреть, какого типа переменная `items1` выше. Поскольку списки могут содержать несколько элементов, они являются контейнерным типом данных, поэтому, когда мы называем переменную типа list, имя переменной обычно представляет собой слово в форме множественного числа.

Кроме того, вы можете превращать другие последовательности в списки с помощью встроенной в Python функции `list`. Если быть точным, `list` - это не обычная функция, а конструктор, создающий объект-список, а с понятиями объектов и конструкторов вы познакомитесь позже в этом курсе.

```python
items4 = list(range(1, 10))
items5 = list('hello')
print(items4)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(items5)  # ['h', 'e', 'l', 'l', 'o']
```

> **Описание**: `range(1, 10)` создает последовательность целых чисел от `1` до `9`, которая, будучи переданной конструктору `list`, создает список целых чисел от `1` до `9`. Строки - это последовательности символов, и `list('hello')` выше создает объект списка, используя символы строки `hello` в качестве элементов списка.

### Операции над списками

Мы можем использовать оператор `+` для реализации объединения двух списков, операция объединения объединит элементы двух списков в один, код показан ниже.

```python
items5 = [35, 12, 99, 45, 66]
items6 = [45, 58, 29]
items7 = ['Python', 'Java', 'JavaScript']
print(items5 + items6)  # [35, 12, 99, 45, 66, 45, 58, 29]
print(items6 + items7)  # [45, 58, 29, 'Python', 'Java', 'JavaScript']
items5 += items6
print(items5)  # [35, 12, 99, 45, 66, 45, 58, 29]
```

我们可以使用`*`运算符实现列表的重复运算，`*`运算符会将列表元素重复指定的次数，我们在上面的代码中增加两行，如下所示。

```python
print(items6 * 3)  # [45, 58, 29, 45, 58, 29, 45, 58, 29]
print(items7 * 2)  # ['Python', 'Java', 'JavaScript', 'Python', 'Java', 'JavaScript']
```

我们可以使用`in`或`not in`运算符判断一个元素在不在列表中，我们在上面的代码代码中再增加两行，如下所示。

```python
print(29 in items6)  # True
print(99 in items6)  # False
print('C++' not in items7)     # True
print('Python' not in items7)  # False
```

由于列表中有多个元素，而且元素是按照特定顺序放在列表中的，所以当我们想操作列表中的某个元素时，可以使用`[]`运算符，通过在`[]`中指定元素的位置来访问该元素，这种运算称为索引运算。需要说明的是，`[]`的元素位置可以是`0`到`N - 1`的整数，也可以是`-1`到`-N`的整数，分别称为正向索引和反向索引，其中`N`代表列表元素的个数。对于正向索引，`[0]`可以访问列表中的第一个元素，`[N - 1]`可以访问最后一个元素；对于反向索引，`[-1]`可以访问列表中的最后一个元素，`[-N]`可以访问第一个元素，代码如下所示。

```python
items8 = ['apple', 'waxberry', 'pitaya', 'peach', 'watermelon']
print(items8[0])   # apple
print(items8[2])   # pitaya
print(items8[4])   # watermelon
items8[2] = 'durian'
print(items8)      # ['apple', 'waxberry', 'durian', 'peach', 'watermelon']
print(items8[-5])  # 'apple'
print(items8[-4])  # 'waxberry'
print(items8[-1])  # watermelon
items8[-4] = 'strawberry'
print(items8)      # ['apple', 'strawberry', 'durian', 'peach', 'watermelon']
```

在使用索引运算的时候要避免出现索引越界的情况，对于上面的`items8`，如果我们访问`items8[5]`或`items8[-6]`，就会引发`IndexError`错误，导致程序崩溃，对应的错误信息是：*list index out of range*，翻译成中文就是“数组索引超出范围”。因为对于只有五个元素的列表`items8`，有效的正向索引是`0`到`4`，有效的反向索引是`-1`到`-5`。

如果希望一次性访问列表中的多个元素，我们可以使用切片运算。切片运算是形如`[start:end:stride]`的运算符，其中`start`代表访问列表元素的起始位置，`end`代表访问列表元素的终止位置（终止位置的元素无法访问），而`stride`则代表了跨度，简单的说就是位置的增量，比如我们访问的第一个元素在`start`位置，那么第二个元素就在`start + stride`位置，当然`start + stride`要小于`end`。我们给上面的代码增加下面的语句，来使用切片运算符访问列表元素。

```python
print(items8[1:3:1])     # ['strawberry', 'durian']
print(items8[0:3:1])     # ['apple', 'strawberry', 'durian']
print(items8[0:5:2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2:1])   # ['strawberry', 'durian']
print(items8[-2:-6:-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

> **提醒**：大家可以看看上面代码中的最后一行，想一想当跨度为负数时，切片运算是如何访问元素的。

如果`start`值等于`0`，那么在使用切片运算符时可以将其省略；如果`end`值等于`N`，`N`代表列表元素的个数，那么在使用切片运算符时可以将其省略；如果`stride`值等于`1`，那么在使用切片运算符时也可以将其省略。所以，下面的代码跟上面的代码作用完全相同。

```python
print(items8[1:3])     # ['strawberry', 'durian']
print(items8[:3:1])    # ['apple', 'strawberry', 'durian']
print(items8[::2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2])   # ['strawberry', 'durian']
print(items8[-2::-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

事实上，我们还可以通过切片操作修改列表中的元素，例如我们给上面的代码再加上一行，大家可以看看这里的输出。

```python
items8[1:3] = ['x', 'o']
print(items8)  # ['apple', 'x', 'o', 'peach', 'watermelon']
```

两个列表还可以做关系运算，我们可以比较两个列表是否相等，也可以给两个列表比大小，代码如下所示。

```python
nums1 = [1, 2, 3, 4]
nums2 = list(range(1, 5))
nums3 = [3, 2, 1]
print(nums1 == nums2)  # True
print(nums1 != nums2)  # False
print(nums1 <= nums3)  # True
print(nums2 >= nums3)  # False
```

> **说明**：上面的`nums1`和`nums2`对应元素完全相同，所以`==`运算的结果是`True`。`nums2`和`nums3`的比较，由于`nums2`的第一个元素`1`小于`nums3`的第一个元素`3`，所以`nums2 >= nums3`比较的结果是`False`。两个列表的关系运算在实际工作并不那么常用，如果实在不理解就跳过吧，不用纠结。

### 元素的遍历

如果想逐个取出列表中的元素，可以使用`for-in`循环的，有以下两种做法。

方法一：在循环结构中通过索引运算，遍历列表元素。

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for index in range(len(languages)):
    print(languages[index])
```

输出：

```
Python
Java
C++
Kotlin
```

> **说明**：上面的`len`函数可以获取列表元素的个数`N`，而`range(N)`则构成了从`0`到`N-1`的范围，刚好可以作为列表元素的索引。

方法二：直接对列表做循环，循环变量就是列表元素的代表。

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for language in languages:
    print(language)
```

输出：

```
Python
Java
C++
Kotlin
```

### 总结

讲到这里，我们可以用列表的知识来重构上面“掷色子统计每种点数出现次数”的代码。

```python
"""
将一颗色子掷6000次，统计每种点数出现的次数

Author: Ло Хао
Version: 1.1
"""
import random

counters = [0] * 6
# 模拟掷色子记录每种点数出现的次数
for _ in range(6000):
    face = random.randrange(1, 7)
    counters[face - 1] += 1
# 输出每种点数出现的次数
for face in range(1, 7):
    print(f'{face}点出现了{counters[face - 1]}次')
```

上面的代码中，我们用`counters`列表中的六个元素分别表示 1 到 6 点出现的次数，最开始的时候六个元素的值都是 0。接下来，我们用 1 到 6 均匀分布的随机数模拟掷色子，如果摇出 1 点，`counters[0]`的值加 1，如果摇出 2 点，`counters[1]`的值加 1，以此类推。大家感受一下，由于使用了列表类型加上循环结构，我们对数据的处理是批量性的，这就使得修改后的代码比之前的代码要简单优雅得多。
