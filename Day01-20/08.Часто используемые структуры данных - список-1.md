## Часто используемые структуры данных списка-1

Прежде чем мы начнем этот урок, мы сначала дадим вам задачу по программированию: 6000 раз бросить кубик, подсчитать, сколько раз появляется каждая точка. Эта задача должна быть очень простой для вас, мы можем использовать от 1 до 6 равномерно распределенных случайных чисел для имитации броска кубика, а затем использовать 6 переменных для записи количества раз появления каждого количества очков, я считаю, что благодаря предыдущему исследованию мы можем написать следующий код более гладко.

```python
"""
Бросить кубик 6000 раз и подсчитать, сколько раз встречается каждое количество очков.

Author: Ло Хао
Version: 1.0
"""
import random

f1 = 0
f2 = 0
f3 = 0
f4 = 0
f5 = 0
f6 = 0
for _ in range(6000):
    face = random.randrange(1, 7)
    if face == 1:
        f1 += 1
    elif face == 2:
        f2 += 1
    elif face == 3:
        f3 += 1
    elif face == 4:
        f4 += 1
    elif face == 5:
        f5 += 1
    else:
        f6 += 1
print(f'1 выпадала {f1} раз')
print(f'2 выпадала {f2} раз')
print(f'3 выпадала {f3} раз')
print(f'4 выпадала {f4} раз')
print(f'5 выпадала {f5} раз')
print(f'6 выпадала {f6} раз')
```

Не нужно говорить, насколько "уродлив" приведенный выше код. Конечно, еще ужаснее то, что если мы хотим перевернуть два или более очков, а затем подсчитать, сколько раз встречается каждое количество точек, то нам нужно определить больше переменных и написать больше ветвящихся структур, что заставляет нас всех чувствовать себя больными на всю голову, когда мы думаем об этом. В этот момент, я уверен, у вас возникает вопрос: есть ли способ использовать одну переменную для хранения нескольких данных, и есть ли способ манипулировать несколькими частями данных с помощью одного фрагмента кода? Ответ - да. В Python вы можете сохранять и манипулировать несколькими частями данных с помощью контейнерных переменных, и для начала мы познакомим вас с новым типом данных `list`.

### Создание списков

В Python **список - это последовательность данных, состоящая из ряда элементов, расположенных в определенном порядке**, а это значит, что если мы определим переменную типа list, **мы сможем использовать ее для хранения нескольких частей данных**. В Python списки могут быть определены с помощью синтаксиса литералов `[]`, где несколько элементов в списке разделяются запятыми, как показано в коде ниже.

```python
items1 = [35, 12, 99, 68, 55, 35, 87]
items2 = ['Python', 'Java', 'Go', 'Kotlin']
items3 = [100, 12.3, 'Python', True]
print(items1)  # [35, 12, 99, 68, 55, 35, 87]
print(items2)  # ['Python', 'Java', 'Go', 'Kotlin']
print(items3)  # [100, 12.3, 'Python', True]
```

> **Примечание**: Списки могут иметь дублирующиеся элементы, например, `35` в `items1`; списки могут иметь элементы разных типов, например, `int`, `float`, `str` и `bool` в `items3`, но мы обычно не рекомендуем помещать элементы разных типов в один список, в основном потому, что это это крайне неудобно для манипуляций.

Мы можем использовать функцию `type`, чтобы узнать тип переменной, так что если вам интересно, то можете сами посмотреть, какого типа переменная `items1` выше. Поскольку списки могут содержать несколько элементов, они являются контейнерным типом данных, поэтому, когда мы называем переменную типа list, имя переменной обычно представляет собой слово в форме множественного числа.

Кроме того, вы можете превращать другие последовательности в списки с помощью встроенной в Python функции `list`. Если быть точным, `list` - это не обычная функция, а конструктор, создающий объект-список, а с понятиями объектов и конструкторов вы познакомитесь позже в этом курсе.

```python
items4 = list(range(1, 10))
items5 = list('hello')
print(items4)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(items5)  # ['h', 'e', 'l', 'l', 'o']
```

> **Описание**: `range(1, 10)` создает последовательность целых чисел от `1` до `9`, которая, будучи переданной конструктору `list`, создает список целых чисел от `1` до `9`. Строки - это последовательности символов, и `list('hello')` выше создает объект списка, используя символы строки `hello` в качестве элементов списка.

### Операции над списками

Мы можем использовать оператор `+` для реализации объединения двух списков, операция объединения объединит элементы двух списков в один, код показан ниже.

```python
items5 = [35, 12, 99, 45, 66]
items6 = [45, 58, 29]
items7 = ['Python', 'Java', 'JavaScript']
print(items5 + items6)  # [35, 12, 99, 45, 66, 45, 58, 29]
print(items6 + items7)  # [45, 58, 29, 'Python', 'Java', 'JavaScript']
items5 += items6
print(items5)  # [35, 12, 99, 45, 66, 45, 58, 29]
```

Мы можем использовать оператор `*` для реализации операции повторения для списков, оператор `*` повторяет элемент списка указанное количество раз, мы добавим две строки в приведенный выше код, как показано ниже.

```python
print(items6 * 3)  # [45, 58, 29, 45, 58, 29, 45, 58, 29]
print(items7 * 2)  # ['Python', 'Java', 'JavaScript', 'Python', 'Java', 'JavaScript']
```

Мы можем использовать оператор `in` или `not in`, чтобы определить, находится ли элемент в списке или нет, и добавляем еще две строки к приведенному выше коду, как показано ниже.

```python
print(29 in items6)  # True
print(99 in items6)  # False
print('C++' not in items7)     # True
print('Python' not in items7)  # False
```

Поскольку в списке есть несколько элементов, и они располагаются в списке в определенном порядке, когда мы хотим манипулировать элементом в списке, мы можем использовать оператор `[]` для доступа к элементу, указав его позицию в `[]`, что известно как операция индексирования. Следует отметить, что позиция элемента в `[]` может быть целым числом от `0` до `N - 1` или от `-1` до `-N`, которые известны как прямой и обратный индексы соответственно, где `N` обозначает количество элементов списка. Для прямого индекса `[0]` получает доступ к первому элементу списка, а `[N - 1]` - к последнему элементу; для обратного индекса `[-1]` получает доступ к последнему элементу списка, а `[-N]` - к первому элементу, как показано в приведенном ниже коде.

```python
items8 = ['apple', 'waxberry', 'pitaya', 'peach', 'watermelon']
print(items8[0])   # apple
print(items8[2])   # pitaya
print(items8[4])   # watermelon
items8[2] = 'durian'
print(items8)      # ['apple', 'waxberry', 'durian', 'peach', 'watermelon']
print(items8[-5])  # 'apple'
print(items8[-4])  # 'waxberry'
print(items8[-1])  # watermelon
items8[-4] = 'strawberry'
print(items8)      # ['apple', 'strawberry', 'durian', 'peach', 'watermelon']
```

При использовании операций индексирования следует избегать выхода индекса за пределы диапазона. Для приведенного выше `items8`, если мы обратимся к `items8[5]` или `items8[-6]`, это вызовет ошибку `IndexError`, которая приведет к ошибке программы, и выдаст соответствующее сообщение об ошибке - *list index out of range*, что переводится как "индекс массива вне диапазона". Причина в том, что для списка `items8`, состоящего всего из пяти элементов, допустимыми прямыми индексами являются `0` - `4`, а допустимыми обратными индексами - `-1` - `-5`.

Если вы хотите получить доступ к нескольким элементам списка за один раз, то можете использовать нарезку. Slicing - это оператор вида `[start:end:stride]`, где `start` представляет начальную позицию элемента списка, к которому осуществляется доступ, `end` представляет конечную позицию элемента списка (элемент в конечной позиции недоступен), а `stride` представляет промежуток, который является простым приращением позиции, например, если мы обращаемся к первому элементу по адресу `start`, то второй элемент находится по адресу `start + stride`, но, конечно, `start + stride` меньше, чем `end`. Добавим к приведенному выше коду следующий оператор для доступа к элементам списка с помощью оператора slice.

```python
print(items8[1:3:1])     # ['strawberry', 'durian']
print(items8[0:3:1])     # ['apple', 'strawberry', 'durian']
print(items8[0:5:2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2:1])   # ['strawberry', 'durian']
print(items8[-2:-6:-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

> **ПОМНИТЕ**: Вы можете посмотреть на последнюю строку в приведенном выше коде и подумать о том, как операция нарезки обращается к элементам, когда интервал отрицателен.

Если значение `start` равно `0`, то его можно опустить при использовании оператора slice; если значение `end` равно `N`, что представляет собой количество элементов в списке, то его можно опустить при использовании оператора slice; и если значение `stride` равно `1`, то его также можно опустить при использовании данного оператора. Таким образом, следующий код делает то же самое, что и код выше.

```python
print(items8[1:3])     # ['strawberry', 'durian']
print(items8[:3:1])    # ['apple', 'strawberry', 'durian']
print(items8[::2])     # ['apple', 'durian', 'watermelon']
print(items8[-4:-2])   # ['strawberry', 'durian']
print(items8[-2::-1])  # ['peach', 'durian', 'strawberry', 'apple']
```

На самом деле, мы также можем изменять элементы в списке с помощью операций среза, например, если мы добавим еще одну строку к приведенному выше коду, то можно увидеть результат здесь.

```python
items8[1:3] = ['x', 'o']
print(items8)  # ['apple', 'x', 'o', 'peach', 'watermelon']
```

Два списка также могут выполнять реляционные операции, мы можем сравнить равны ли два списка или можно сравнить размер двух списков. Код следующий.

```python
nums1 = [1, 2, 3, 4]
nums2 = list(range(1, 5))
nums3 = [3, 2, 1]
print(nums1 == nums2)  # True
print(nums1 != nums2)  # False
print(nums1 <= nums3)  # True
print(nums2 >= nums3)  # False
```

> **Примечание**: `nums1` и `nums2` выше соответствуют абсолютно одинаковым элементам, поэтому результатом операции `==` является `True`. Сравнение `nums2` и `nums3` приводит к `False` при сравнении `nums2 >= nums3`, поскольку первый элемент `1` из `nums2` меньше, чем первый элемент `3` из `nums3`. Реляционная операция над двумя списками не так часто встречается на практике, поэтому если вы действительно не понимаете ее, просто пропустите, не утруждайте себя.

### Перебор элементов

Если вы хотите доставать элементы списка по одному, вы можете использовать цикл `for-in`, который может быть выполнен двумя способами.

Метод 1: Итерация по элементам списка с помощью операций индексации в структуре цикла.

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for index in range(len(languages)):
    print(languages[index])
```

Вывод:

```
Python
Java
C++
Kotlin
```

> **Примечание**: Функция `len` выше получает количество элементов списка `N`, а `range(N)` представляет собой диапазон от `0` до `N-1`, который как раз и является индексом элементов списка.

Метод 2: Выполните цикл непосредственно над списком, где переменная цикла содержит элемент списка.

```python
languages = ['Python', 'Java', 'C++', 'Kotlin']
for language in languages:
    print(language)
```

Вывод:

```
Python
Java
C++
Kotlin
```

### Резюме

На данный момент мы можем использовать наши знания о списках для рефакторинга приведенного выше кода для "подсчета количества раз, когда каждое очко встречается при броске костей".

```python
"""
Бросить кубик 6000 раз и подсчитать, сколько раз встречается каждое количество очков.

Author: Ло Хао
Version: 1.1
"""
import random

counters = [0] * 6
# Имитируем перекатывание кубика, 
# чтобы записать количество раз, когда встречается каждое количество очков
for _ in range(6000):
    face = random.randrange(1, 7)
    counters[face - 1] += 1
# Вывести количество повторений каждой точки
for face in range(1, 7):
    print(f'{face} был выброшен {counters[face - 1]} раз')
```

В приведенном выше коде мы используем шесть элементов в списке `counters` для представления количества раз, когда встречаются точки от 1 до 6, и значение каждого из шести элементов равно 0. Далее мы имитируем выпадение кубика с помощью равномерно распределенных случайных чисел от 1 до 6. Если мы получаем 1, значение `counters[0]` увеличивается на 1, если получаем 2, значение `counters[1]` увеличивается на 1, и так далее. Если вы получите 2 очка, значение `counters[1]` увеличится на 1, и так далее. Чтобы дать вам представление, благодаря типу данных список и структуре цикла мы обрабатываем данные партиями, что делает модифицированный код намного проще и элегантнее предыдущего.