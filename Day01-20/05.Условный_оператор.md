## Условный оператор

До сих пор мы писали программы на Python, которые выполняют по одному оператору в последовательном нисходящем направлении, что называется последовательной структурой. Однако последовательная структура сама по себе не может решить всех проблем. Например, если мы разрабатываем игру, в которой на первом уровне игроку нужно набрать 1000 очков, то в конце первого уровня нам нужно решить, переходить ли на второй уровень, основываясь на количестве набранных игроком очков, или сообщить игроку, что «Игра окончена». В этом сценарии наш код будет иметь две ветви, и только одна из них будет выполнена. Существует множество других подобных сценариев, и мы называем такую структуру «ветвящейся структурой» или «структурой выбора». Если у вас есть минута, вы сможете придумать еще как минимум 5 примеров, так что попробуйте!

### Использование if и else для построения ветвящихся структур

В Python ключевые слова `if`, `elif` и `else` чаще всего используются для построения ветвящихся структур. **Ключевое слово** - это слово, которое имеет особое значение в языке программирования, и, очевидно, вы не можете использовать его в качестве имени переменной. Конечно, мы не используем все три ключевых слова каждый раз, когда строим ветвящуюся структуру, поэтому давайте проиллюстрируем это на примере. Допустим, мы хотим написать калькулятор индекса массы тела (ИМТ). Индекс массы тела - это международная мера того, насколько толстым или тонким является человеческое тело, а также здоровым или нет, формула которой приведена ниже. Обычно считается, что $\small{18,5 \le ИМТ < 24}$ - это нормальный диапазон, $\small{ИМТ < 18,5}$ - недостаточный вес, $\small{ИМТ \ge 24}$ - избыточный вес, а $\small{ИМТ \ge 27}$ попадает в категорию ожирения.

$$
BMI = \frac{вес}{рост^{2}}
$$

> **Примечание**: Вес в приведенной выше формуле выражается в килограммах (кг), а рост - в метрах (м).

```python
"""
Калькулятор ИМТ

Version: 1.0
Author: Ло Хао
"""
height = float(input('Рост(cm)：'))
weight = float(input('Вес(kg)：'))
bmi = weight / (height / 100) ** 2
print(f'{bmi = :.1f}')
if 18.5 <= bmi < 24:
    print('Вы в отличной форме!')
```

> **Подсказка**: оператор `if` имеет `:` в конце, это двоеточие, набранное в английской раскладке; `'`, `'`, `=`, `(`, `)` и другие специальные символы, набранные в программе, набраны в английской раскладке, о чем уже напоминалось ранее. Многие новички часто игнорируют этот момент, вплоть до того, что при выполнении кода вы увидите большое количество сообщений об ошибках. Конечно, внимательно прочитав сообщение об ошибке, все равно легко найти, где проблема, но **настоятельно рекомендуем** всем при написании кода **переключиться на английскую раскладку**, так вы сможете избежать множества ненужных неприятностей.

В приведенном выше коде, после расчета и вывода ИМТ, мы добавили структуру ветвления, если условие $\small{18.5 \le BMI < 24}$ выполнено, программа выведет «У вас отличное тело!». Но если условие не выполняется, то вывода не будет. Это то, о чем говорилось ранее, - код может иметь разные пути выполнения, и некоторый код может выполняться не всегда. Мы ввели выражение `18.5 <= bmi < 24` после ключевого слова `if`, и, как мы уже говорили, реляционная арифметика выдаёт булевы значения, и если булево значение после `if` равно `True`, то под оператором `if` с разрывом в четыре пробела `print('У тебя отличное тело!')` будет выполнена. Давайте запустим приведенный выше код с несколькими наборами входных данных, как показано ниже.

Первый набор входных данных:

```
Рост(cm)：175
Вес(kg)：68
bmi = 22.2
Вы в отличной форме!
```

Второй набор входных данных:

```
Рост(cm)：175
Вес(kg)：95
bmi = 31.0
```

Третий набор входных данных:

```
Рост(cm)：175
Вес(kg)：50
bmi = 16.3
```

Только первый набор входных данных имеет ИМТ в диапазоне от 18,5 до 24, поэтому срабатывает условие `if` и выводится сообщение «У вас отличное тело». Следует отметить, что в отличие от C, C++, Java и других языков программирования, Python не использует скобки для построения блоков кода, а вместо этого **использует отступ для представления иерархии кода**, так что если вам нужно выполнить несколько выражений, если условие `if` истинно, вам просто нужно сохранить одинаковый отступ для всех выражений. Другими словами, несколько последовательных строк выражений с одинаковым отступом относятся к одному **блоку кода**, что эквивалентно выполнению всего кода в целом. Вы можете использовать любое количество пробелов для отступа, но **обычно используется 4 пробела**. Настоятельно рекомендуется **не использовать клавишу табуляции (Tab key) для отступа кода**, если вы привыкли это делать, то можете настроить ваш редактор кода на автоматическое превращение 1 табуляции в 4 пробела, многие редакторы кода поддерживают эту функцию, и она также установлена по умолчанию в PyCharm. Еще один момент, в C, C++, Java и т.д `18.5 <= bmi < 24` следует записывать как два условия, `bmi >= 18.5` и `bmi < 24`, а затем соединить эти два условия оператором `and`, что можно сделать и в Python, например, для оператора `if` можно также записать как `if bmi >= 18.5 and bmi < 24:`, но это не обязательно. Не правда ли, хорошо выглядит, если написать `if 18.5 <= bmi < 24:`? Вот код на Java, который делает то же самое. Ничего страшного, если вы не можете прочитать код на Java, просто почувствуйте разницу между ним и синтаксисом Python.

```java
import java.util.Scanner;

class Test {

    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            System.out.print("Рост(cm): ");
            double height = sc.nextDouble();
            System.out.print("Вес(kg): ");
            double weight = sc.nextDouble();
            double bmi = weight / Math.pow(height / 100, 2);
            System.out.printf("bmi = %.1f\n", bmi);
            if (bmi >= 18.5 && bmi < 24) {
                System.out.println("Вы в отличной форме!");
            }
        }
    }
}
```

> **Примечание**: выше приведен Java-код для калькулятора BMI версии 1.0. Не зря предпочтение отдается Python, так как он обычно решает ту же задачу с меньшим количеством кода.

Далее, давайте немного модифицируем приведенный выше код, чтобы он также выдавал сообщение о необходимости проверки, если ИМТ не удовлетворяет условию $\small{18.5 \le BMI < 24}$. Мы можем добавить блок `else` после блока `if`, который будет выполнен, если условие, заданное в операторе `if`, не будет выполнено, как показано ниже. Очевидно, что при `print('Вы в отличной форме!') в `if` и `print('Ты не в форме, йоу!') под `else` будет выполнена только одна из них.

```python
"""
Калькулятор ИМТ

Version: 1.1
Author: Ло Хао
"""
height = float(input('Рост(cm)：'))
weight = float(input('Вес(kg)：'))
bmi = weight / (height / 100) ** 2
print(f'{bmi = :.1f}')
if 18.5 <= bmi < 24:
    print('Вы в отличной форме！')
else:
    print('Ты не  форме, йоу！')
```

Чтобы дать более точную подсказку, мы можем снова модифицировать приведенный выше код, добавив дополнительные ветви в вышеуказанную структуру ветвления с помощью ключевого слова `elif`, как показано ниже.

```python
"""
Калькулятор ИМТ

Version: 1.2
Author: Ло Хао
"""
height = float(input('Рост(cm)：'))
weight = float(input('Вес(kg)：'))
bmi = weight / (height / 100) ** 2
print(f'{bmi = :.1f}')
if bmi < 18.5:
    print('У Вас недостаточный вес!')
elif bmi < 24:
    print('Вы в отличной форме！')
elif bmi < 27:
    print('У Вас лишний вес！')
elif bmi < 30:
    print('У Вас легкая степень ожирения！')
elif bmi < 35:
    print('У Вас умеренное ожирение！')
else:
    print('У Вас сильное ожирение！')
```

Давайте снова протестируем приведенный выше код с тремя наборами данных, которые мы только что использовали, и посмотрим, какие результаты получим.

Первый набор входных данных:

```
РОст(cm)：175
Вес(kg)：68
bmi = 22.2
Вы в отличной форме!
```

Второй набор входных данных:

```
Рост(cm)：175
Вес(kg)：95
bmi = 31.0
У вас умеренное ожирение!
```

Третий набор входных данных:

```
Рост(cm)：175
Вес(kg)：50
bmi = 16.3
У Вас недостаточный вес!
```

### Использование match и case для построения ветвящихся структур

В Python 3.10 добавлен новый способ построения ветвящихся структур, который позволяет легко создавать многоветвящиеся структуры с помощью ключевых слов `match` и `case`. В официальной документации Python новый синтаксис описывается на интересном примере распознавания кода статуса HTTP-ответа (вывод описания на основе статуса HTTP-ответа). Это очень интересно. Если вы не знаете, что такое статус HTTP-ответа, посмотрите [документацию](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status) на MDN. Мы объясним синтаксис в немного измененной версии официального примера, начиная с приведенного ниже кода, в котором используется структура `if-else`.

```python
status_code = int(input('Код состояния: '))
if status_code == 400:
    description = 'Bad Request'
elif status_code == 401:
    description = 'Unauthorized'
elif status_code == 403:
    description = 'Forbidden'
elif status_code == 404:
    description = 'Not Found'
elif status_code == 405:
    description = 'Method Not Allowed'
elif status_code == 418:
    description = 'I am a teapot'
elif status_code == 429:
    description = 'Too many requests'
else:
    description = 'Unknown status Code'
print('Описание кода состояния:', description)
```

Результаты выполнения:

```
Код состояния: 403
Описание кода состояния: Forbidden
```

Следующий код реализован с использованием синтаксиса `match-case`, и хотя он делает то же самое, код выглядит проще и элегантнее.

```python
status_code = int(input('Код состояния: '))
match status_code:
    case 400: description = 'Bad Request'
    case 401: description = 'Unauthorized'
    case 403: description = 'Forbidden'
    case 404: description = 'Not Found'
    case 405: description = 'Method Not Allowed'
    case 418: description = 'I am a teapot'
    case 429: description = 'Too many requests'
    case _: description = 'Unknown Status Code'
print('Описание кода состояния:', description)
```

> **Описание**: Операторы `case` с `_` действуют как подстановочные знаки в коде, который приходит к `case _`, если ни одна из предыдущих ветвей не совпадает. Утверждения `case _` необязательны, не каждая структура ветки должна давать возможность выбора подстановочного знака. Если `case _` присутствует в ветке, он должен быть помещен только в конец структуры, и если за ним следуют другие ветки, то они будут недоступны.

Конечно, существует множество более сложных способов работы с синтаксисом `match-case`, и один из них - шаблон слияния, которому можно обучиться в первую очередь. Например, если мы хотим сгруппировать коды статуса ответа `401`, `403` и `404` в одну ветку, `400` и `405` в другую, а все остальное оставить без изменений, код можно написать следующим образом.

```python
status_code = int(input('Код состояния: '))
match status_code:
    case 400 | 405: description = 'Invalid Request'
    case 401 | 403 | 404: description = 'Not Allowed'
    case 418: description = 'I am a teapot'
    case 429: description = 'Too many requests'
    case _: description = 'Unknown Status Code'
print('Описание кода состояния:', description)
```

Результаты выполнения:

```
Код состояния: 403
Описание кода состояния: Not Allowed
```

### Применение разветвляющихся структур

#### Пример 1: Нахождение значения сегментированной функции

Ниже показана сегментированная функция, для которой требуется ввести `x` и вычислить `y`.

$$
y = \begin{cases} 3x - 5, & (x \gt 1) \\\\ x + 2, & (-1 \le x \le 1) \\\\ 5x + 3, & (x \lt -1) \end{cases}
$$

```python
"""
Сегментированная функция для нахождения значения

Version: 1.0
Author: Ло Хао
"""
x = float(input('x = '))
if x > 1:
    y = 3 * x - 5
elif x >= -1:
    y = x + 2
else:
    y = 5 * x + 3
print(f'{y = }')
```

В зависимости от потребностей реальной разработки, разветвляющиеся структуры могут быть вложенными, то есть в блоке `if`, `elif` или `else` разветвляющейся структуры могут быть использованы повторно. Например, если условие `if` истинно и игрок проходит уровень, но после прохождения уровня вы оцениваетесь в зависимости от количества полученных сокровищ или реквизита (например, одна, две или три звезды), то нам нужно построить новую структуру ветвления внутри `if`. Аналогично, мы можем построить новые ветви внутри `elif` и `else`, которые мы называем вложенными ветвящимися структурами. Таким образом, описанная выше сегментированная оценка функции может быть реализована с помощью следующего кода.

```python
"""
Сегментированная функция для нахождения значения

Version: 1.1
Author: Ло Хао
"""
x = float(input('x = '))
if x > 1:
    y = 3 * x - 5
else:
    if x >= -1:
        y = x + 2
    else:
        y = 5 * x + 3
print(f'{y = }')
```

> **Примечание**: Вы можете сами почувствовать и оценить, какой из двух описанных выше способов написания лучше. В [**Дзен Python**](https://ru.wikipedia.org/wiki/%D0%94%D0%B7%D0%B5%D0%BD_%D0%9F%D0%B0%D0%B9%D1%82%D0%BE%D0%BD%D0%B0)» есть такое предложение: "**Плоское лучше, чем вложенное**". Причина, по которой я считаю, что "плоский" код лучше, заключается в том, что большое количество вложенных уровней может серьезно повлиять на читабельность кода. Поэтому лично я рекомендую первый способ написания.

#### Пример 2: преобразование процентных баллов в оценки

Требования: если входная оценка выше 90 (включая 90), то выведите `A`; если входная оценка от 80 до 90 (исключая 90), то выведите `B`; если входная оценка от 70 до 80 (исключая 80), то выведите `C`; если входная оценка от 60 до 70 (исключая 70), то выведите `D`; и если входная оценка ниже 60, то выведите `E`. Ниже этого значения выводится `E`.

```python
"""
Перевод процентных баллов в оценки

Version: 1.0
Author: Ло Хао
"""
score = float(input('Пожалуйста, введите свои результаты: '))
if score >= 90:
    grade = 'A'
elif score >= 80:
    grade = 'B'
elif score >= 70:
    grade = 'C'
elif score >= 60:
    grade = 'D'
else:
    grade = 'E'
print(f'{grade = }')
```
#### Пример 3: Вычислить периметр и площадь треугольника

Требования: Введите длины трех сторон и вычислите периметр и площадь, если треугольник может быть образован; в противном случае выдайте сообщение «невозможно создать треугольник».

```python
"""
Вычислить периметр и площадь треугольника

Version: 1.0
Author: Ло Хао
"""
a = float(input('a = '))
b = float(input('b = '))
c = float(input('c = '))
if a + b > c and a + c > b and b + c > a:
    perimeter = a + b + c
    print(f'Периметр: {perimeter}')
    s = perimeter / 2
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    print(f'Площадь: {area}')
else:
    print('Невозможно создать треугольник')
```
> **Описание:** Условие `if` выше означает, что сумма любых двух сторон больше третьей стороны, которая необходима для образования треугольника. Когда это условие выполняется, мы сможем вычислить и вывести периметр и площадь, поэтому под `if` находятся пять утверждений, которые все сохраняют одинаковый отступ, являются одним и тем же, и все они выполняются до тех пор, пока выполняется условие `if`, что является концепцией блока кода, о которой мы говорили ранее. Кроме того, приведенная выше формула для вычисления площади треугольника называется формулой Хелена. Предположим, имеется треугольник со сторонами $\small{a}$, $\small{b}$ и $\small{c}$, тогда площадь треугольника, $\small{A}$, может быть получена по формуле $\small{A = \sqrt{s(s-a)(s-b)(s-c)}}$. где $s=\frac{a + b + c}{2}$ обозначает половину периметра.

### Резюме

Изучение операторов ветвления и циклических структур в Python позволит нам решать множество реальных задач. Я думаю, что этот урок помог вам освоить метод построения ветвящихся структур, а в следующем уроке мы познакомим вас с циклическими структурами. После этих двух уроков вы наверняка обнаружите, что можете написать много интересного кода, так что продолжайте в том же духе!
