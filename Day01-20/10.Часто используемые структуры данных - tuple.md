## Часто используемые структуры данных tuple

В предыдущих двух уроках мы рассказали о списках в Python, которые представляют собой контейнерные типы данных, позволяющие хранить несколько фрагментов данных и работать с ними пакетно с помощью циклов. Конечно, в Python есть и другие контейнерные типы данных, поэтому мы расскажем о другом контейнерном типе данных, который называется кортеж.

### Определения и операции с кортежами

В Python кортеж - это последовательность элементов, расположенных в определенном порядке. Кортежи отличаются от списков тем, что **кортежи неизменяемы**, то есть после определения переменной типа tuple никакие элементы не могут быть добавлены или удалены, а значения элементов не могут быть изменены. Попытка изменить элементы кортежа приведет к ошибке `TypeError`, что вызовет аварийное завершение программы. Кортежи обычно определяются с помощью литерального синтаксиса, например `(x, y, z)`, а операторы, поддерживаемые типом кортежа, такие же, как и для списков, как показано в следующем коде.

```python
# Тройничный кортеж
t1 = (35, 12, 98)
# Определение кватерниона
t2 = ('Ло Хао', 45, True, 'Чэнду, Сычуань')

# Просмотр типа переменной
print(type(t1))  # <class 'tuple'>
print(type(t2))  # <class 'tuple'>

# Просмотр количества элементов в кортеже
print(len(t1))  # 3
print(len(t2))  # 4

# Операция индексирования
print(t1[0])    # 35
print(t1[2])    # 98
print(t2[-1])   # Чэнду, Сычуань

# Операция среза
print(t2[:2])   # ('Ло Хао', 43)
print(t2[::3])  # ('Ло Хао', 'Чэнду, Сычуань')

# Перебор элементов кортежа
for elem in t1:
    print(elem)

# Операция принадлежности
print(12 in t1)         # True
print(99 in t1)         # False
print('Hao' not in t2)  # True

# Операция объединения
t3 = t1 + t2
print(t3)  # (35, 12, 98, 'Ло Хао', 43, True, 'Чэнду, Сычуань')

# Операции сравнения
print(t1 == t3)            # False
print(t1 >= t3)            # False
print(t1 <= (35, 11, 99))  # False
```

Если в кортеже два элемента, мы называем его бинарным кортежем; если в кортеже пять элементов, мы называем его квинтуплетом. Предупреждение: `()` обозначает пустой кортеж, но если в кортеже только один элемент, нужно добавить запятую, иначе `()` - это не буквальный синтаксис для представления кортежа, а скобки, которые меняют приоритет операций, поэтому `('hello', )` и `(100, )` - это только кортежи из одного элемента, а `('hello')` и `(100)` - это только строками и целыми числами. Мы можем убедиться в этом с помощью следующего кода.

```python
a = ()
print(type(a))  # <class 'tuple'>
b = ('hello')
print(type(b))  # <class 'str'>
c = (100)
print(type(c))  # <class 'int'>
d = ('hello', )
print(type(d))  # <class 'tuple'>
e = (100, )
print(type(e))  # <class 'tuple'>
```

### Операции упаковки и распаковки

Когда мы присваиваем переменной несколько значений, разделенных запятыми, значения упаковываются в кортеж; когда мы присваиваем кортеж нескольким переменным, кортеж распаковывается на несколько значений и присваивается соответствующим переменным, как показано в следующем коде.

```python
# Операция упаковки
a = 1, 10, 100
print(type(a))  # <class 'tuple'>
print(a)        # (1, 10, 100)
# Операция распаковки
i, j, k = a
print(i, j, k)  # 1 10 100
```

При распаковке, если количество распакованных элементов не соответствует количеству переменных, будет выброшено исключение `ValueError` с сообщением об ошибке `too many values to unpack` или `not enough values to unpack`.

```python
a = 1, 10, 100, 1000
# i, j, k = a             # ValueError: too many values to unpack (expected 3)
# i, j, k, l, m, n = a    # ValueError: not enough values to unpack (expected 6, got 4)
```

Один из способов решить проблему, когда переменных меньше, чем элементов - использовать выражение со звездочкой. С помощью выражения со звездочкой мы можем заставить переменную принимать более одного значения, как показано в приведенном ниже коде. Следует отметить два момента: во-первых, переменная, измененная с помощью выражения со звездочкой, становится списком с нулем или более элементов, а во-вторых, выражение со звездочкой может встречаться только один раз в синтаксисе разворачивания.

```python
a = 1, 10, 100, 1000
i, j, *k = a
print(i, j, k)        # 1 10 [100, 1000]
i, *j, k = a
print(i, j, k)        # 1 [10, 100] 1000
*i, j, k = a
print(i, j, k)        # [1, 10] 100 1000
*i, j = a
print(i, j)           # [1, 10, 100] 1000
i, *j = a
print(i, j)           # 1 [10, 100, 1000]
i, j, k, *l = a
print(i, j, k, l)     # 1 10 100 [1000]
i, j, k, l, *m = a
print(i, j, k, l, m)  # 1 10 100 1000 []
```

Чтобы было понятно, синтаксис разворачивания применим ко всем последовательностям, а это значит, что списки, о которых мы говорили ранее, последовательности диапазонов, построенные функцией `range`, и даже строки могут быть использованы с синтаксисом разворачивания. Вы можете попробовать выполнить следующий код и посмотреть, что получится.

```python
a, b, *c = range(1, 10)
print(a, b, c)
a, b, c = [1, 10, 100]
print(a, b, c)
a, *b, c = 'hello'
print(a, b, c)
```

### Обмен значений переменных

Обмен значений двух переменных - обычная операция при написании кода, но во многих языках программирования обмен значений двух переменных требует использования промежуточной переменной, а если вы не используете промежуточную переменную, то для этого необходимо использовать непонятные побитовые операции. В Python обмен значениями двух переменных, `a` и `b`, можно выполнить с помощью следующего кода.

```python
a, b = b, a
```

Аналогично, если нужно поменять местами значения трех переменных `a`, `b` и `c`, то есть присвоить значение `b` значению `a`, значение `c` - значению `b`, а значение `a` - значению `c`, это можно сделать следующим образом.

```python
a, b, c = b, c, a
```

Следует отметить, что в приведенной выше операции не используется синтаксис упаковки и распаковки, для прямой реализации этой операции можно использовать инструкции байткода Python, такие как `ROT_TWO` и `ROT_THREE`, что очень эффективно. Однако, если необходимо поменять местами более трех переменных, не существует директивы байткода, которую можно было бы использовать напрямую, поэтому для завершения обмена значениями между переменными необходимо упаковать и распаковать их.

### Сравнение кортежей и списков

Вот еще один вопрос, который стоит изучить: зачем нам нужны кортежи, если в Python уже есть списки? Этот вопрос кажется немного сложным для новичков, но это неважно, давайте разберем точки зрения, чтобы вы могли учиться по ходу дела.

1. Кортежи - это неизменяемые типы, а **неизменяемые типы лучше подходят для многопоточных сред**, потому что они уменьшают накладные расходы на синхронизацию при одновременном доступе к переменным. Мы обсудим это позже, когда будем рассказывать о параллельном программировании.

Кортежи - неизменяемые типы, и обычно **неизменяемые типы превосходят свои мутабельные аналоги** по времени создания. Мы можем использовать функцию `timeit` модуля `timeit`, чтобы узнать, сколько времени требуется для создания кортежа и списка, содержащих одинаковые элементы, причем параметр `number` функции `timeit` указывает на количество раз выполнения кода. В следующем коде мы создаем списки и кортежи, содержащие целые числа от `1` до `9`, и выполняем каждую операцию `10,000,000` раз, подсчитывая время выполнения.

   ```python
   import timeit
   
   print('%.3f секунд' % timeit.timeit('[1, 2, 3, 4, 5, 6, 7, 8, 9]', number=10000000))
   print('%.3f секунд' % timeit.timeit('(1, 2, 3, 4, 5, 6, 7, 8, 9)', number=10000000))
   ```

   Вывод:

   ```
   0.635 секунд
   0.078 секунд
   ```

   > **Примечание**: Результаты выполнения приведенного выше кода зависят от аппаратного и программного обеспечения системы компьютера, который я использую в данный момент, время выполнения `10 000 000` операций для создания списка составляет `0,635` секунд, в то время как время выполнения `10 000 000` операций для создания кортежа составляет `0,078` секунд, очевидно, что создание кортежа происходит быстрее и разница между этими двумя временами составляет порядок величины. Очевидно, что создание кортежа происходит быстрее, и разница во времени между ними на порядок больше. Вы можете запустить этот код на своем компьютере и выложить результаты в разделе комментариев, чтобы узнать, чей компьютер лучше.

Конечно, кортежи и списки в Python можно преобразовывать друг в друга, и мы можем сделать это с помощью следующего кода.

```python
infos = ('Ло Хао', 43, True, 'Чэнду, Сычуань')
# Преобразование кортежей в списки
print(list(infos))  # ['Ло Хао', 43, True, 'Чэнду, Сычуань']

frts = ['apple', 'banana', 'orange']
# Преобразование списков в кортежи
print(tuple(frts))  # ('apple', 'banana', 'orange')
```

### Подведем итоги.

**Списки и кортежи являются контейнерными типами данных**, т.е. одна переменная может содержать более одного элемента данных, и они являются упорядоченными контейнерами с элементами, расположенными в определенном порядке. **Списки являются изменяемыми типами данных**, а кортежи - **неизменяемыми типами данных**, поэтому в списки можно добавлять элементы, удалять, очищать элементы и изменять их порядок, но для кортежей эти операции недоступны. И списки и кортежи поддерживают такие операции, как **объединение**, **создание элемента**, **индексирование**, **разбивка** и т.д. Тип строки, о котором мы поговорим позже, также поддерживает эти операции, потому что строка - это последовательность символов в определенном порядке, и в этом отношении между ними нет никакой разницы. Мы **рекомендуем вам использовать генеративный синтаксис для списков** для создания списков, который не только полезен, но и очень эффективен, и является очень своеобразным синтаксисом в Python.
